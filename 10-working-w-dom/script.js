'use strict';

// * === Работа с DOM === * \\

// * 1.0 В этом уроке мы практикуемся работе с DOM-деревом. У нас есть простая вёрстка, состоящая из двух списков, один из которых заполнен элементами. Эти элементы мы будем удалять и перемещать.
// 1.1 Получим нужные нам элементы списков и их внутренних элементов.
const lists = document.querySelectorAll('.list');
const elems = document.querySelectorAll('.elem');

console.log(lists);
console.log(elems);

// * Метод "remove()"

// 1.2 Теперь удалим 3-ий и 5-ый элементы. Они были удалены только лишь из вёрстки. 
// ? 1.3.1 Кстати, даже если мы не будем применять методы remove(), после append() оба элемента также исчезнут из первого списка. Это говорит о том, что метод append() перемещает элементы по странице, а не просто вставляет. Т.е. он берёт элемент с исходного места и помещает в элемент к которому мы применили метод append(), а точнее в самый конец, после последнего из списка дочерних элементов.
/* elems[2].remove();
elems[4].remove(); */

console.log(elems);

// * Метод "append()"

// * 1.3.0 Однако в самой переменной elems они остались и можно их переиспользовать, например переложить во второй список. Обратимся ко второму списку при помощи индекса и применим метод "append()".
// 1.3.2 Для демонстрации переставим третий элемент за пятым.
lists[1].append(elems[2]);
lists[1].append(elems[4]);
lists[1].append(elems[2]);

// * Метод "prepend()"

// 1.4 Ещё есть очень похожий на "append" метод "prepend", который вставляет элементы в самое начало перед списком всех дочерних элементов. Поставим, например первый элемент первого списка в самое начало второго списка.
lists[1].prepend(elems[0]);

// * Метод "before()"

// 1.5.0 Позволяет вставить какой-то элемент перед определённым элементом. Например мы можем поменять списки местами, а также поменять местами их дочерние элементы, например 2-ой элемент первого списка с первым элементом второго списка.
lists[0].before(lists[1]);

elems[1].before(elems[4]);

// * Метод "after()"

// 1.5.1 Также работает и "after", только вставляет элемент соответственно после определённого элемента.
elems[2].after(elems[3]);

// * Метод "replaceWith()"

// 1.6.0 Меняет местами два определённых элемента
elems[0].replaceWith(elems[1]); // Теперь элемент с индексом 0 был полностью заменён элементом с индексом 1 и 0-вой пропал из вёрстки.
// 1.6.1 Также мы могли бы заменить элемент и какой-либо строкой
elems[3].replaceWith('Hello World!')

// ? 1.6.2 Точно также передача значения работает и с методами "append", "prepend", "before" & "after"
elems[5].append('\nПривет Мир!')

// * 1.7.0 Что если мы хотим клонировать, сделать точную копию какого-то элемента?
// 1.7.1 Так мы этого не добьёмся, это всего лишь ссылка на элемент. Также как и с объектами, это всего лишь ссылка на исходный элемент, и соответственно, изменяя элемент по этой ссылке будет изменяться и исходный элемент.
const notClonedElem = elems[3];

// * Метод "cloneNode()"

// 1.7.2 Так как же быть? Сделать настоящую копию нам поможет метод "cloneNode". Но если оставить () метода пустыми, то мы получим только верхний узел элемента. Чтобы клонировать также все включённый внутренние узлы нужно записать внутрь "true".
const clonedElem = elems[4].cloneNode(true);

// 1.7.3 Теперь вставил клонированный элемент в первый список. Т.к. он на самом деле клон, независимый от изначального элемента, то он также появится в первом списке, не исчезая из второго.
// 1.7.4 Хотя, прежде, чем добавлять его в первый список мы можем добавить ему какой-то класс, чтобы стилизовать по новому и заменить его текстовый узел на другой текст.
clonedElem.classList.add('green-color');
clonedElem.textContent = 'a link';

// 1.7.5 А что, если мы хотим ему добавить ещё какой-то тег, например сделать его настоящей ссылкой. Здесь мы можем использовать свойство "innerHTML", которое хранит не только текстовую ноду, но и вёрстку элемента.
clonedElem.innerHTML = '<a href="#">a link</a>';

lists[1].append(clonedElem);

// * == Создание нового элемента == * \\

// * Метод "createElement()"
// ? В виде параметра передаём строкой название тега, который хотим создать. Создавать можно абсолютно любой тег.

// * 1.8.0 Итак мы создаём новый тег <li>
const newElem = document.createElement('li');
// 1.8.1 Пока он ещё не находится в вёрстке, а только в памяти JS, но мы уже можем видеть пустой тег "li" через console.log
console.log(newElem);
// 1.8.2 Также добавим ему текстовое содержимое и класс
newElem.textContent = 'step 3';
newElem.classList.add('elem');
// 1.8.3 А затем добавим во второй список
lists[1].append(newElem);

// * == Вставка кусков вёрстки == * \\

// * Свойство "innerHTML" (пример см. чуть выше строка 72)
// ? Не просто добавляет в вёрстку какие-то строчки, которые передаём, а полностью затирает старое и добавляет новое. Так можно что-то удалять из вёрстки просто присваивая пустую строку ''.

const title = document.getElementById('title');

// ? Методы "insertAdjacentText", "insertAdjacentElement" & "insertAdjacentHTML", появившиеся в относительно свежих редакциях JS также добавляют новые текстовые узлы и новую вёрстку, но в отличии от свойств "textContent" & "innerHTML" делают это не трогая старые данные.

// * Метод "insertAdjacentText()"
// ? 1-ый аргумент — настройка куда вставлять (afterbegin, afterend, beforebegin, beforeend); 2-ой текст, который вставляем
// ? Для наглядности будем вставлять одноимённый опции текст, чтобы видеть как работает та или иная опция
title.insertAdjacentText('afterbegin', 'afterbegin');
title.insertAdjacentText('afterend', 'afterend');
title.insertAdjacentText('beforebegin', 'beforebegin');
title.insertAdjacentText('beforeend', 'beforeend');

// * Метод "insertAdjacentElement()"
// ? Работает похожим образом, что и "insertAdjacentText", но только вместо строки мы передаём какой-то элемент
/* title.insertAdjacentElement('afterbegin', elems[0]);
title.insertAdjacentElement('afterend', elems[1]);
title.insertAdjacentElement('beforebegin', elems[2]);
title.insertAdjacentElement('beforeend', elems[3]); */

// * Метод "insertAdjacentHTML()"
// ? Работает похожим образом, что и "insertAdjacentText" с "insertAdjacentElement", но только вместо строки и элемента мы передаём какую-то часть вёрстки
/* title.insertAdjacentHTML('afterbegin', '<p>p</p>');
title.insertAdjacentHTML('afterend', '<em>em</em>');
title.insertAdjacentHTML('beforebegin', '<strong>strong</strong>');
title.insertAdjacentHTML('beforeend', '<h2>h2</h2>'); */

// * == Устаревшие методы для работы с DOM == * \\

// ? Есть ряд устаревших методом, которым пришли на замену более совершенные, рассмотренные выше методы из новых редакций JS стандартов, но их до сих пор можно встретить в старых проектах, поэтому знать их нужно.

// * Метод "appendChild()"
// ? Более новая альтернатива => "append()"
// Кроме более короткой записи у append есть ряд других преимуществ. К примеру мы можем добавлять несколько разных элементов одной строчкой. "appendChild" же проигнорирует все аргументы, кроме первого, т.к. может принять лишь один.
// lists[0].append(elems[4], elems[3], elems[2]);
// lists[1].appendChild(elems[4], elems[3], elems[2]);

// Также в метод "appendChild" мы не можем передавать строку
// lists[0].append('Hello World!'); // работает
// lists[1].appendChild('Hello World!'); // ошибка

// Ещё одно принципиальное отличие, что "appendChild" возвращает тот элемент, который мы добавляем через него.
// const el = lists[1].appendChild(elems[0]);
// const el2 = lists[1].append(elems[0]);

// console.log(el); // вернёт элемент
// console.log(el2); // undefined

// * Метод "insertBefore()"
// ? Более новая альтернатива => "before()"

// "insertBefore" отличается от "before" тем, что мы зависим от родительского элемента, т.е. на него мы применяем метод. Далее первым аргументом указать тот элемент, который будем перемещать, а вторым тот, перед которым его следует поместить. Очевидно, что метод "before" несколько удобнее в применении.
// lists[1].insertBefore(elems[5], elems[1]);

// * Метод "replaceChild()"
// ? Более новая альтернатива => "replaceWith()"

// Во многом похож на "insertBefore" и также зависит от родительского элемента.
lists[1].replaceChild(elems[5], elems[1]);

// * Метод "removeChild()"
// ? Более новая альтернатива => "remove()"

// Во многом похож на "insertBefore" & "replaceChild", также зависит от родительского элемента и принимает один аргумент в виде элемента, который будет удалён.
lists[0].removeChild(elems[4]);

/* ||---------------------------------------------->> 
* Links:
* [][https://learn.javascript.ru/modifying-document] Изменения документа (LearnJS)
* [][https://habr.com/ru/post/413287/] DocumentFragment
* [][https://webdevblog.ru/ispolzuem-dom-kak-pro/] Используем DOM как Pro
*/ 