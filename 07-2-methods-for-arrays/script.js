'use strict';

// * === Методы для работы с массивами === * \\

// ? Чаще всего сервер будет присылать нам на фронтэнд данные в виде массивов. Поэтому важно знать методы работы с ними.
// В данном примере у нас массив объектов, который представляет собой 5 книг.
const books = [
	{id: 0, name: 'Дорога домой', author: 'Виталий Зыков', price: 1200},
	{id: 1, name: 'Война за выживание', author: 'Виталий Зыков', price: 1500},
	{id: 2, name: 'Мир бесчисленных островов', author: 'Виталий Зыков', price: 1300},
	{id: 3, name: 'Далекая страна', author: 'Алекс Кош', price: 950},
	{id: 4, name: 'Адреналин', author: 'Алекс Кош', price: 1650},
]

// * == Добавление и удаление элементов == * \\

// * 1) «concat» — arr.concat(arg1, arg2...) — работает похоже на конкатенацию строк, т.е. возьмёт массив и склеит его с переданными в аргументы элементы или массивы, т.е. создаст из них новый массив.

const newArr = books.concat({id: 5, name: 'Школа Пепла', author: 'Виталий Зыков', price: 1980});

console.log(newArr);

// * 2) «slice» — arr.slice([start], [end]) — возвращает новый массив, в который копирует элементы исходного массива, начиная с индекса «start» и заканчивая индексом «end» (не включая элемент с последним указанным индексом).

const newArr2 = books.slice(0, 3);

console.log(newArr2);

// * 3) «splice» — arr.splice(index, deleteCount, elements) — универсальный метод, умеющий, как добавлять, так и удалять элементы, практически умеет всё то, что умеют предыдущие оба метода, однако работает он иначе, чем они. Он не возвращает новый, а изменяет исходный массив. Принимает 3 аргумента: 1) индекс удаляемого элемента, 2) кол-во удаляемых элементов начиная с индекса, указанного первым аргументом, 3) (опционально) можем указать элементы, которые будем добавлять.

books.splice(2, 3); // удаляем элементы

console.log(books); // остались лишь первые две книги из 5

books.splice(2, 3, {id: 5, name: 'Школа Пепла', author: 'Виталий Зыков', price: 1980}, {id: 6, name: 'Гарри Поттер и узник Азкабана', author: 'Джоан Роулинг', price: 1999}); // удаляем и добавляем элементы

console.log(books); // удалились все книги, кроме первых двух, а потом добавились в конец ещё две, указанные нами в методе

// * == Поиск == * \\

// ? Группа методов, которые мы используем, чтобы определить существует ли какой-то элемент внутри нашего массива, либо найти его индекс, либо получить булево значение, в зависимости от того, находится ли заданный элемент в массиве или не находится.

// * 1) «find» — принимает в себя коллбэк, которые в свою очередь принимает 3 аргумента: а) item — каждый очередной элемент, b) index - его индекс, с) array - сам массив.
// ? Метод «find» перебирает массив в поисках нужного элемента

/* const result = arr.find(function(item, index, array)) {
	если true: возвращается текущий элемент и перебор прерывается
	если все три итерации оказались ложными: возвращается undefined
} */

const result = books.find(function(itm, idx, arr) {
	return itm.name === 'Дорога домой';
})

console.log(result); // находим именно тот объект, чьё свойство «name» — «Дорогая домой».

// ? Также мы можем искать по любому свойству объектов. Например найдём объект массива, свойство «id» которого равно 3.

const result2 = books.find(function(itm, idx, arr) {
	return itm.id === 5;
})

console.log(result2);

// * 2) «findIndex» — брат-близнец метода «find», который возвращает index элемента, найденного в массиве. 

const resultIndex = books.findIndex(function(itm, idx, arr) {
	return itm.author === 'Джоан Роулинг';
})

console.log(resultIndex);

// Теперь, зная индекс элемента, мы можем применить метод splice, чтобы удалить его.

books.splice(resultIndex, 1);

console.log(books);

// * == Методы перебора и преобразования массивов == * \\

// ? Иногда к нам приходят с сервера данные не совсем в том формате, который нам нужен и чтобы привести их в нужный нам вид есть очень полезные методы «forEach», «map» и «filter».

// ? На самом деле у всех трёх очень похожий синтаксис. Они, также, как и метод «find» принимают аргументом коллбэк-функцию, который в свою очередь принимает каждый последующий элемент при итерации, его индекс и весь перебираемый массив.
// ? Но хотя синтаксис и похож, функционал очень отличается друг от друга.

// * 1) «forEach» — стандартный метод перебора массива. Он перебирает весь наш массив и для каждого элемента массива по-очереди вызовет функцию коллбэк.
// ? Не создаёт новый массив, а изменяет исходный.

// array.forEach(function(item, index, array) {
// 	# ... какие-то взаимодействия с item ...
// });

// Представим, что у нас задание к цене каждой книги прибавить значок «₽».
books.forEach(function(item) {
	item.price += ' ₽';
});

console.log(books);

// * 2) «map» — работает также, как и «forEach», но...
// ? ...в отличии от «forEach» метод «map» создаёт новый массив.

// const result = array.map(function(item, index, array) {
// 	# ... возвращается новое значение вместо элемента ...
// });

// Создадим новый массив, в который пока скопируем исходный массив без изменений.

const newArray = books.map(function(item) {
	return item;
})

// Теперь books & newArray — абсолютно идентичные, но при этом разные массивы.

// ? В некоторых задачах бывает очень важно мочь собрать новый массив на основе предыдущего, изменив какие-то его свойства, но оставив исходный массив нетронутым.

// К примеру, вернём на каждой итерации объект, у которого есть только лишь свойства id и name.
const newBooksShelf = books.map(function (item) {
	const newObject = {
		id: item.id,
		name: item.name
	}
	return newObject;
})

console.log(newBooksShelf);

// ? Это нам открывает большие просторы для экспериментов, например можно добавить новые свойства или сделать массив не объектов, а только числе или только строк.

// * 3) «filter» — работает, как и метод «map», но добавит в новый массив только те элементы, которые пройдут проверку, а остальные "отфильтрует" вне нового массива.
// ? Создаёт новый массив.
// const result = array.filter(function(item, index, array) {
// 	# ... если true — элемент добавляется к результату, и перебор продолжается, 
// 	но если ничего не найдено, то получим пустой массив ...
// });

// Например, у нас задание — оставить в массиве лишь те книги, которые написал Виталий Зыков.

const zykovBooks = books.filter(function (item) {
	return item.author === 'Виталий Зыков'; // после return запишем условие для фильтрации элементов
})

console.log(zykovBooks);

// * == Последовательная обработка == * \\

// * «reduce» — пробегает по всему элементу, берёт значение какого-то определённого свойства элемента (например price) и складывает в один контейнер. Метод «reduce» также принимает второй после коллбэка аргумент — некое число initial, это число, с которого начинаются расчёты. Например для суммы всех цен мы указали 0. (Но в случае, где у нас например происходит последовательное умножение, то у нас есть возможность поставить вместо нуля единицу.)
/* const value = array.reduce(function(previousValue, item, index, array) {
	# ... code ...
}, [initial]); */

// Представим, что у нас есть задача, что в шапке страницы есть корзина товаров, куда нужно выводить итоговую стоимость выбранных пользователем книг.
const books2 = [
	{id: 0, name: 'Дорога домой', author: 'Виталий Зыков', price: 1200},
	{id: 1, name: 'Война за выживание', author: 'Виталий Зыков', price: 1500},
	{id: 2, name: 'Мир бесчисленных островов', author: 'Виталий Зыков', price: 1300},
	{id: 3, name: 'Далекая страна', author: 'Алекс Кош', price: 950},
	{id: 4, name: 'Адреналин', author: 'Алекс Кош', price: 1650},
]

const totalSum = books2.reduce(function(sum, item) {
	return sum + item.price;
}, 0)
/* const totalMultiply = books2.reduce(function(sum, item) {
	return sum * item.price;
}, 1) */

console.log(totalSum);
// console.log(totalMultiply);

// * «reduceRight» — у метода «reduce» есть брат-близнец и работает он точно также, только справа налево. В сложении мы не заметим разницу, но в умножении конечно это имеет большое значение.

const totalMultiply2 = books2.reduceRight(function(sum, item) {
	return sum + item.price;
}, 0)