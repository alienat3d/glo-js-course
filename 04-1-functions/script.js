'use strict';
// * === Функции, анонимные функции, callback - функции, чистые функции === * \\
// ? Функция это основной функциональный блок любой программы. В JS нам очень часто нужно повторять одно и тоже действие во многих частях программы. Чтобы не повторять один и тот же код во многих местах придуманы функции. И рекомендуется каждый законченный алгоритм заключать в функцию. Так программу становится проще читать, в ней проще разобраться и делать debugging.
// ? Объявлять функцию можно 3-мя разными способами:
// * 1) function declaration (объявления функций) — отличается тем, что использовать её можно как в коде после, так и перед её объявлением.

function getMessage() {
	console.log('Hello world!'); // тело функции внутри {}
}

// getMessage(); // вызов функции
// И теперь мы можем сколько угодно раз выполнять тело функции где нам потребуется без того, чтобы дублировать код
/* getMessage();
getMessage(); */

// ? В программировании хорошей практикой является, когда большая задача разбивается на множество подзадач поменьше. Каждая подзадача заключается в функцию. И каждая функция тщательно описывается. Далее эти функции вызываются в нужном порядке.
// Рассмотрим на примере задачи "Нужны чистые руки", разобьём её на три части: 1) испачканные руки, 2) пойти в ванную, 3) вымыть руки.
// ? Если присмотреться к каждой из функций внутри, то обнаружим, что они делают тоже самое — выводят строку в консоль. А значит мы можем сократить код, убрав его дублирование, благодаря свойству функции "передача аргументов".

/* function cleanHands() {
	function getDirtyHands() {
		console.log('Испачкать руки');
	}
	function goToBathroom() {
		console.log('Пойти в ванную комнату');
	}
	function cleaningHands() {
		console.log('Вымыть руки');
	}

	getDirtyHands();
	goToBathroom();
	cleaningHands();
}

cleanHands(); */

// Итак мы сократим наши шаги до одного, а строки будем передавать в виде аргумента.

// ? В программировании, разница между аргументом и параметром заключается в том, что аргумент – это фактическое значение, которое передается функции, а параметр – это переменная, используемая функцией для получения и работы с этим значением. Здесь string — это параметр, а строки — аргументы. Параметры можно представить также как некие переменные, куда могут попадать различные данные - аргументы.
// ? Параметров может быть сколько угодно и называть мы их можем также как угодно, но они должны иметь смысл, чтобы любому программисту можно было сразу понять какие данные этот параметр принимает.

function cleanHands() {
	function step(index, string) {
		console.log(index + ") " + string);
	}

	step(1, 'Испачкать руки');
	step(2, 'Пойти в ванную комнату');
	step(3, 'Вымыть руки');
}

cleanHands();

// * 2) function expression (выражение функции) — использовать её можно ТОЛЬКО после её объявления, что делает код более стабильным и потому на практике является более предпочтительным вариантом, чем function declaration. По аналогии с переменной объявленной через ключевое слово "const".

// greets(); // вызовет ошибку

const greets = function () {
	console.log('Hello world!'); // тело функции внутри {}
}

greets();

// * 3) Ещё один способ, который используется крайне редко в сложных веб-приложениях, когда другого способа не найти. На данный момент можно встретить в основном только в старых приложениях в силу сложности использования.

const someMessage = new Function('index', 'message', 'console.log(message)');

// * ===================================== * \\

// * Немного практики * \\

/* const countSum = function(a, b) { 
	const res = a + b;

	console.log(res);
} */

// console.log(res); // выйдет ошибка, т.к. переменные, объявленные внутри функции не видны снаружи

// countSum(3, 5);

// * Но зато мы можем объявить переменную перед функцией, а внутри функции присвоить ей другое значение.
/* let res;

const countSum = function(a, b) { 
	res = a + b;
}

countSum(3, 5);

console.log(res); */

// * Также мы могли бы результат выполнения функции сразу назначить значением переменной res
/* const countSum = function(a, b) { 
	return a + b; // для этого нам нужно возвращать из функции решение выражения
} */
// ? Внимание, после строчки со словом return никакой другой код не имеет смысла, т.к. после возвращения значения функция тут же завершает свою работу.

// * А при записи сокращённой стрелочной функцией не пришлось бы даже писать return.
// const countSum = (a, b) => a + b;

/* const res = countSum(3, 5);

console.log(res); */

// * Или мы можем совсем избавиться от переменной res
// console.log(countSum(3, 5));
// * Или использовать результат выполнения функции с другими математическими операциями
// console.log(countSum(3, 5) * 8);

// * Мы можем указывать значения по умолчанию для любых параметров, на случай, если их значения не будут переданы.
const countMultiply = function (a, b = 0) {
	return a * b;
}

console.log(countMultiply(5, 3));
console.log(countMultiply(5)); // без значения по умолчанию для b здесь была бы ошибка

// * Мы можем указать сколь угодно аргументов при вызове функции, однако использоваться будут только первые (столько штук, сколько у нас параметров), однако остальные всё равно можно будет получить через специальный псевдомассив "arguments". С ним мы в этом курсе работать не будем, т.к. чтобы получить все аргументы переданные в функцию есть более простые и современные способы в новом стандарте JS.
// ? В настоящее время применять псевдомассив arguments в работе не рекомендуется, т.к. с выходом новых редакций ES многие его методы были заблокированы, т.к. они плохо влияли на работу функций. Есть более современные и лучшие способы для работы с аргументами функций.
const countDivision = function (a, b = 1) {
	console.log(arguments[arguments.length - 1]); // например получим последний аргумент
	return a / b;
}

console.log(countDivision(9, 3, 4, 15, 63, 99, 155));

// todo Также см. [../piece-of-code/concat.js]

// * Чистые функции («детерминированные») * \\
// ? «Чистой функцией» или «детерминированной» называют такую функцию, результат выполнения которой зависит только от входных параметров. Также для чистоты необходимо ещё одно условие — они не должны нести в себе побочные эффекты, такие как: вызовы в консоль, алерты, обращения к серверу и обращения к DOM-дереву.
// ? Очень рекомендуется соблюдать чистоту кода также внутри функции, ведь такие функции гораздо проще читать, поддерживать и тестировать.
// Однако постоянно писать лишь чистые функции невозможно, ведь нам довольно часто приходится обращаться к серверу или к DOM-дереву. И всё же лучше писать чистые функции везде, где это возможно.
const countSubtraction = function (a, b) {
	return a - b;
}

console.log(countSubtraction(10, 5));

// Рассмотрим альтернативный вариант, где результат выполнения функции зависит также от значения внешней переменной count
// Проблема с такими функциями может заключаться в том, что переменная, участвующая в функционале такой функции может находится где-то далеко вверху от описания этой функции и её могут поменять. А т.к. результат поменяется вместе со значением этой переменной, то такая функция не является «чистой».
let count = 5;

const countSubtractionDirty = function (a, b) {
	return a - b - count;
}

console.log(countSubtractionDirty(10, 5));

// * == Callback-функции == * \\

// ? Коллбэк-функции — это функции обратного вызова. Внутрь функции мы можем передавать не только числа и строки, но также объекты, массивы и функции. Но мы можем не только принимать функции, но мы можем её принять в параметр и запустить этот параметр.

// 1.3 А в первую функцию мы добавим ещё один параметр "callback". И теперь будем запускать его внутри функции, принимая в него параметр b
const countSum2 = function (a, b, callback) {
	return a + callback(b);
}
// 1.0 Опишем вторую функцию...
const secondFunc2 = function (num) {
	return num + 2;
}
// 1.1 ...и передадим её в виде аргумента в countSum2().
console.log(countSum2(2, 5, secondFunc2));

// 1.4 Итак, пошагово, что у нас происходит вверху ↑: в параметр "a" передаётся 2, а в "b" — 5, а в параметр "callback" ссылка на другую функцию secondFunc, которая параметром "num" принимает параметр "b" и выполняет вычисление "5 + 2", передаёт 7 в функцию countSum2 и в итоге результат возвращается 9.

// * == Анонимные функции == * \\

// 2.0 Первая у нас обычная функция
function one() {
	console.log('one');
}
// 2.1 А вторая анонимная. (Но мы всегда можем дать ей имя, если потребуется.)
const two = function () {
	console.log('two');
}

console.log(one);
console.log(two);

// 2.2 Итак, выше мы передавали функцию secondFunc2 как аргумент (или точнее как коллбэк), но при этом она заносилась в переменную secondFunc2
const countSum3 = function (a, b, callback) {
	return a + callback(b);
}

const secondFunc3 = function (num) {
	return num + 2;
}
// 2.3 А что, если мы будем передавать сразу функцию, без использования лишней переменной? И мы видим, что результат всё тот же, при этом мы не используем лишнюю переменную, которая занимает как минимум 1 лишнюю ячейку в памяти. 
console.log(countSum2(2, 5, function (num) {
	return num + 2;
}));

// ? Функции, которые мы используем лишь разово можно и нужно использовать в виде анонимных. Так они проще читаются и мы не загрязняем пространство имён, не создавая лишних имён переменных или функций.

// * Немного практики для закрепления темы коллбэков и анонимных функций * \\

// 3.0 Представим, что у нас есть зарплата (переменная «money»), а также две статьи расходов (переменные «expenses1» & «expenses2»)
const money = 5000;
const expenses1 = 200;
const expenses2 = 300;

// 3.2 Но что, если сумма расходов нам может понадобится где-то ещё в другой части скрипта? Мы можем записать нахождение суммы расходов в отдельную функцию.
const totalExpenses = function (exp1, exp2) {
	return exp1 + exp2;
}

// 3.1 Мы написали функцию, которая вычисляет остаток денег, после оплаты необходимых расходов.
// 3.3 А теперь мы подставим функцию нахождения суммы расходов в функцию, которая вычисляет остаток денег.
// 3.4 А ещё мы можем передать значение «money» в виде параметра этой функции, а функцию totalExpenses() в виде коллбэка, таким образом сделав функцию countTotal() чистой.
const countTotal = function (count, callback) {
	// return money - expenses1 - expenses2;
	// return money - totalExpenses(expenses1, expenses2);
	return count - callback(expenses1, expenses2);
}

console.log(countTotal(money, totalExpenses));
console.log(totalExpenses(expenses1, expenses2));

// * Пример двух функций, где одна с таймаутом * \\

// Как мы можем заметить, не смотря на то, что fastFunc() в коде стоит ниже slowFunc(), но благодаря тому, что у slowFunc() стоит отсрочивающий выполнение таймер setTimeout, то она срабатывает после fastFunc() через 2 секунды.
// Но можно ли сделать так, чтобы fastFunc() всё-таки сработала после slowFunc()? Да, тут помогут коллбэки.
const slowFunc = function (call) {
	setTimeout(function () {
		console.log('slowFunc сработала');
		call();
	}, 2000);
}

const fastFunc = function() {
	console.log('fastFunc сработала');
}

slowFunc(fastFunc);

// * == Вложенные функции (nested functions) и замыкания (closures) == * \\

/* Вы можете вложить одну функцию в другую. Вложенная функция (nested function; inner) приватная (private) и она помещена в другую функцию (outer). Так образуется замыкание (closure). Closure — это выражение (обычно функция), которое может иметь свободные переменные вместе со средой, которая связывает эти переменные (что "закрывает" ("close") выражение).

Поскольку вложенная функция это closure, это означает, что вложенная функция может "унаследовать" (inherit) аргументы и переменные функции, в которую та вложена. Другими словами, вложенная функция содержит scope внешней ("outer") функции.

? --> Вложенная функция имеет доступ ко всем инструкциям внешней функции.
? --> Вложенная функция формирует closure: она может использовать аргументы и переменные внешней функции, в то время как внешняя функция не может использовать аргументы и переменные вложенной функции.
*/

function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
console.log(a = addSquares(2, 3)); // возвращает 13
console.log(b = addSquares(3, 4)); // возвращает 25
console.log(c = addSquares(4, 5)); // возвращает 41

// * == Остаточные параметры (Rest parameters) == * \\

// ? Остаточные параметры предоставляют нам массив неопределённых аргументов.

// В примере мы используем остаточные параметры, чтобы собрать аргументы с индексами со 2-го до последнего. Затем мы умножим каждый из них на значение первого аргумента. В этом примере используется стрелочная функция (Arrow functions), о которой будет рассказано в следующей секции.

function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]

/* ||---------------------------------------------->> 
* Links:
* [✓][https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions] Функции
* [✓][https://habr.com/ru/post/151716/] Callback функции
* [https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/] ES6 In Depth: Arrow functions
*/ 