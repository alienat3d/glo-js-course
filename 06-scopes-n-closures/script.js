'use strict';

// * === Область видимости и замыкания. === * \\

// ? Переменная, которая объявлена в основном «теле» программы, доступна везде внутри этого кода.
// 1.0 Переменная «a» — это глобальная переменная и имеет глобальную область видимости.

const a = 5;

function func() {
	const b = 10;

	console.log(a);
	console.log(b); // 1.1 переменная «b» видна только внутри функции func() и во вложенных в неё функциях
}

func();
// console.log(b); // 1.2 А попытка вызвать её в консоль снаружи функции, где она объявлена — вызовет ошибку.

// ? Кстати, если бы мы не написали в начале "use strict", то можно было бы создать переменную где угодно, без объявления её с помощью ключевых слов "const" & "let", тогда она бы попадала в глобальную зону видимости. Эту проблему устраняет "строгий режим" и в нём такая оплошность вызовет ошибку.

// ? Когда интерпретатор начинает считывать код, то видя переменные он задаёт каждой из них её область видимости, из которой она будет доступна. Это происходит ещё при инициализации кода.

// Рассмотрим на примере: Итак метод console.log() внутри функции one обращается к переменной num, чтобы получить из неё данные, внутри функции one её не находит и поднимается на уровень выше и т.д. пока не найдёт её, иначе выкинет ошибку. Однако, если внутри функции будет объявлена ещё одна переменная с таким же именем, то именно её значение будет приоритетным и console.log() не пойдёт искать дальше.

// ? Итак, ещё раз для закрепления console.log() в функции two сперва смотрит в своём скрытом объекте LexicalEnvironment переменные num & x, не находя их там, смотрит в своём объекте Scope, находит там «x», дальше в поисках «num» переходит в родительский объект LexicalEnvironment, не находит его и переходит в родительский Scope, где и находит значение глобальной переменной «num», т.е. 5. 

let num = 5;

function one(x, z) {
	// LexicalEnvironment = { x: 3, z: undefined }
	// const num = 10;
	// LexicalEnvironment = { x: 3, z: undefined }
	// Scope = { num: 5 }
	console.log(num, x, z);

	function two() {
		// LexicalEnvironment = { } ведь в функции two не объявлено ни одной переменной и в неё не переданы параметры
		// Scope = { x: 3, z: undefined } но у функции есть также и второй скрытый объект «Scope», который ссылкой принимает все переменные объявленные в функции-родителе (или точнее сюда попадает ссылка на весь LexicalEnvironment следующего по иерархии уровня). Поэтому родительские переменные становятся доступны дочерним, но не наоборот.
		console.log(num, x);
	}

	two();
}

one(3);

// ? Внутри каждой функции есть специальный объект LexicalEnvironment (лексическая среда), где содержатся все локальные переменные этой функции.

// ? Ещё стоит знать, что LexicalEnvironment определяется в момент вызова функции, а Scope в момент считывания описания функции.
// Проверим на практике
let g = 7;

// f берётся из LexicalEnvironment, а g из Scope (глобальной области видимости).
function someSum(f) {
	console.log(f + g);
}

function some() {
	let g = 20;
	someSum(11)
}

some(); // запустив эту функцию, мы определим в ней переменную g присвоив ей значение 20. А потом вызовем функцию sum передав ей 11. И мы получим 18, вместо 31. Это происходит потому, что функция sum не имеет g и в момент исполнения будет искать его в Scope, где найдёт глобальную переменную g со значением 7, а не из LexicalEnvironment другой функции some, про значение g которой она не знает.

// ? Находящиеся друг другу параллельно функции не могут видеть переменные друг друга, а могут лишь использовать внешние переменные. У них разные области видимости.

// * Замыкания * \\

// ? Если описать совсем просто, то «замыкание» — это функция внутри функции.

/* function funcOne(x) {
	function funcTwo() {
		console.log(x);
		console.dir(funcTwo); // мы увидим, что у funcTwo есть объект Scopes, а в нём свойство Closure (замыкание) и оно нам показывает, что функция funcTwo() и переменная «x» замкнуты в функции funcOne().
	}

	funcTwo();
}

funcOne(3); */

// 2.0 Попробуем более глубже разобраться в замыкании. Перепишем те же функции, но теперь будем спрашивать пользователя ввести какое-то число и поместить его в переменную someNumber.
// 2.1 Заметим, что функция funcTwo про значение «x» прекрасно знает, хотя внутри funcTwo она не задана. Параметр «x» замкнут вместе с этой функцией, а функция всего лишь меняет его значение.

function funcOne(x) {
	function funcTwo() {
		// const someNumber = +prompt("Введите какое-то число?");
		// 2.3 Но значение переменной x не обнуляется к изначальному, оно замкнуто вне функции funcTwo. Оно замкнуто в функции funcOne вместе с функцией funcTwo. Функция funcTwo видит это значение и может как-то его использовать и с ним взаимодействовать, но эта переменная полностью принадлежит функции funcOne и поэтому пересоздавая своё «тело» funcTwo не вернёт x к исходному состоянию.
		x--;

		// console.log(someNumber);
		console.log(x);

		/* 		if (someNumber !== x) {
					// 2.2 Когда мы перезапускаем функцию funcTwo, то она полностью пересоздаст своё «тело», заново задаётся вопрос пользователю, уменьшает значение x на 1, выводится информация в консоль и проводится проверка.
					funcTwo(); 
				} */
	}

	funcTwo();
}

funcOne(10);

// * 3.0 Для закрепления темы рассмотрим более интересный случай — напишем функцию счётчик

function counter(n) {
	// 3.2 Анонимная функция при каждом её вызове знает (в своём Scope) про эту переменную n и использует её в выражении сложения
	return function (x) {
		return x + n;
	}
}

let sum = counter(1); // 3.1 значение n замкнуто внутри функции counter

console.log(sum(15));
console.log(sum(20));

// * 4.0 Рассмотрим ещё одну вполне реальную ситуацию из жизни: Представим, что у нас в проекте несколько папок с картинками и каждый раз URL к этим картинкам нам приходится вставлять вручную. Создадим генератор URL к этим картинкам, чтобы нам нужно было каждый раз вставлять только название этих картинок.

function generatePath(url) {

	// 4.1 Замкнутая анонимная функция будет возвращать url + imageName
	return function (imageName) {
		return url + imageName;
	}
}

// 4.2 Результат мы сохраним в переменную urlToIcons
let urlToIcons = generatePath('https://mydomain.ru/assets/icons/');
let urlToImages = generatePath('https://mydomain.ru/assets/images/');

console.log(urlToIcons('clock.svg'));
console.log(urlToImages('man.png'));

/* ||---------------------------------------------->> 
* Links:
* [✓][https://myrusakov.ru/javascript-closures.html] Область видимости и замыкания
* [][https://medium.com/nuances-of-programming/%D1%8F-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-3c3f02041970] О замыкании
*/ 