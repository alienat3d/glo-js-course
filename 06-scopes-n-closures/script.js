'use strict';

// * === Область видимости и замыкания. === * \\

// ? Переменная, которая объявлена в основном «теле» программы, доступна везде внутри этого кода.
// 1.0 Переменная «a» — это глобальная переменная и имеет глобальную область видимости.

const a = 5;

function func() {
	const b = 10;

	console.log(a);
	console.log(b); // 1.1 переменная «b» видна только внутри функции func() и во вложенных в неё функциях
}

func();
// console.log(b); // 1.2 А попытка вызвать её в консоль снаружи функции, где она объявлена — вызовет ошибку.

// ? Кстати, если бы мы не написали в начале "use strict", то можно было бы создать переменную где угодно, без объявления её с помощью ключевых слов "const" & "let", тогда она бы попадала в глобальную зону видимости. Эту проблему устраняет "строгий режим" и в нём такая оплошность вызовет ошибку.

// ? Когда интерпретатор начинает считывать код, то видя переменные он задаёт каждой из них её область видимости, из которой она будет доступна. Это происходит ещё при инициализации кода.

// Рассмотрим на примере: Итак метод console.log() внутри функции one обращается к переменной num, чтобы получить из неё данные, внутри функции one её не находит и поднимается на уровень выше и т.д. пока не найдёт её, иначе выкинет ошибку. Однако, если внутри функции будет объявлена ещё одна переменная с таким же именем, то именно её значение будет приоритетным и console.log() не пойдёт искать дальше.

// ? Итак, ещё раз для закрепления console.log() в функции two сперва смотрит в своём скрытом объекте LexicalEnvironment переменные num & x, не находя их там, смотрит в своём объекте Scope, находит там «x», дальше в поисках «num» переходит в родительский объект LexicalEnvironment, не находит его и переходит в родительский Scope, где и находит значение глобальной переменной «num», т.е. 5. 

let num = 5;

function one(x, z) {
	// LexicalEnvironment = { x: 3, z: undefined }
	// const num = 10;
	// LexicalEnvironment = { x: 3, z: undefined }
	// Scope = { num: 5 }
	console.log(num, x, z);

	function two() {
		// LexicalEnvironment = { } ведь в функции two не объявлено ни одной переменной и в неё не переданы параметры
		// Scope = { x: 3, z: undefined } но у функции есть также и второй скрытый объект «Scope», который ссылкой принимает все переменные объявленные в функции-родителе (или точнее сюда попадает ссылка на весь LexicalEnvironment следующего по иерархии уровня). Поэтому родительские переменные становятся доступны дочерним, но не наоборот.
		console.log(num, x);
	}

	two();
}

one(3);

// ? Внутри каждой функции есть специальный объект LexicalEnvironment (лексическая среда), где содержатся все локальные переменные этой функции.

// ? Ещё стоит знать, что LexicalEnvironment определяется в момент вызова функции, а Scope в момент считывания описания функции.
// Проверим на практике
let g = 7;

// f берётся из LexicalEnvironment, а g из Scope (глобальной области видимости).
function someSum(f) {
	console.log(f + g);
}

function some() {
	let g = 20;
	someSum(11)
}

some(); // запустив эту функцию, мы определим в ней переменную g присвоив ей значение 20. А потом вызовем функцию sum передав ей 11. И мы получим 18, вместо 31. Это происходит потому, что функция sum не имеет g и в момент исполнения будет искать его в Scope, где найдёт глобальную переменную g со значением 7, а не из LexicalEnvironment другой функции some, про значение g которой она не знает.

// ? Находящиеся друг другу параллельно функции не могут видеть переменные друг друга, а могут лишь использовать внешние переменные. У них разные области видимости.

// * Замыкания * \\

// ? Если описать совсем просто, то «замыкание» — это функция внутри функции.

/* function funcOne(x) {
	function funcTwo() {
		console.log(x);
		console.dir(funcTwo); // мы увидим, что у funcTwo есть объект Scopes, а в нём свойство Closure (замыкание) и оно нам показывает, что функция funcTwo() и переменная «x» замкнуты в функции funcOne().
	}

	funcTwo();
}

funcOne(3); */

// 2.0 Попробуем более глубже разобраться в замыкании. Перепишем те же функции, но теперь будем спрашивать пользователя ввести какое-то число и поместить его в переменную someNumber.
// 2.1 Заметим, что функция funcTwo про значение «x» прекрасно знает, хотя внутри funcTwo она не задана. Параметр «x» замкнут вместе с этой функцией, а функция всего лишь меняет его значение.

function funcOne(x) {
	function funcTwo() {
		// const someNumber = +prompt("Введите какое-то число?");
		// 2.3 Но значение переменной x не обнуляется к изначальному, оно замкнуто вне функции funcTwo. Оно замкнуто в функции funcOne вместе с функцией funcTwo. Функция funcTwo видит это значение и может как-то его использовать и с ним взаимодействовать, но эта переменная полностью принадлежит функции funcOne и поэтому пересоздавая своё «тело» funcTwo не вернёт x к исходному состоянию.
		x--;

		// console.log(someNumber);
		console.log(x);

		/* 		if (someNumber !== x) {
						2.2 Когда мы перезапускаем функцию funcTwo, то она полностью пересоздаст своё «тело», заново задаётся вопрос пользователю, уменьшает значение x на 1, выводится информация в консоль и проводится проверка.
					funcTwo(); 
				} */
	}

	funcTwo();
}

funcOne(10);

// * 3.0 Для закрепления темы рассмотрим более интересный случай — напишем функцию счётчик

function counter(n) {
	// 3.2 Анонимная функция при каждом её вызове знает (в своём Scope) про эту переменную n и использует её в выражении сложения
	return function (x) {
		return x + n;
	}
}

let sum = counter(1); // 3.1 значение n замкнуто внутри функции counter

console.log(sum(15));
console.log(sum(20));

// * 4.0 Рассмотрим ещё одну вполне реальную ситуацию из жизни: Представим, что у нас в проекте несколько папок с картинками и каждый раз URL к этим картинкам нам приходится вставлять вручную. Создадим генератор URL к этим картинкам, чтобы нам нужно было каждый раз вставлять только название этих картинок.

function generatePath(url) {

	// 4.1 Замкнутая анонимная функция будет возвращать url + imageName
	return function (imageName) {
		return url + imageName;
	}
}

// 4.2 Результат мы сохраним в переменную urlToIcons
let urlToIcons = generatePath('https://mydomain.ru/assets/icons/');
let urlToImages = generatePath('https://mydomain.ru/assets/images/');

console.log(urlToIcons('clock.svg'));
console.log(urlToImages('man.png'));

// ================== \\

const val = 7;
function createAdder() {
	function addNumbers(a, b) {
		const ret = a + b;
		return ret;
	}
	return addNumbers;
}

const adder = createAdder();
const sum2 = adder(val, 8);
console.log('example of function returning a function: ', sum2);

// ================== \\

function createCounter() {
	let counter = 0;
	const myFunction = function () {
		counter = counter + 1
		return counter;
	}
	return myFunction;
}
const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();
console.log('example increment', c1, c2, c3); // example increment 1, 2, 3

/* 
Всякий раз, когда вы объявляете новую функцию и присваиваете ее переменной, вы сохраняете определение функции, а также замыкание. Замыкание содержит все переменные, которые находятся в области действия на момент создания функции. Это аналог рюкзака. Определение функции идет как бы с “небольшим рюкзаком”. И в своем “рюкзаке” оно хранит все переменные, которые находились в области действия (scope) на момент создания определения функции.
*/

// ? Замыкание – это коллекция всех переменных в области видимости во время создания функции.
// Концепция замыканий становится актуальной, когда функция возвращает функцию. Возвращенная функция имеет доступ к переменным, которых нет в глобальной области видимости, но они существуют только в ее замыкание.
// Аналогия о которой я всегда буду помнить в случае замыканий – это аналогия с рюкзаком. Когда функция создается и передается или возвращается из другой функции, она несет с собой этот самый “рюкзак”. И в этом “рюкзаке” находятся все переменные, которые были в области видимости, когда функция была объявлена.

// * Не самые обычные замыкания * \\

// Иногда замыкания появляются, когда вы даже не замечаете этого. Возможно, вы видели похожий пример:
let c = 4;
const addX = x => n => n + x;
const addThree = addX(3);
let d = addThree(c);
console.log('example partial application', d);

// В случае, если стрелочные функции сбивает вас с толку, напишем эквивалент.
/* 
Мы объявляем функцию сумматора addX2, которая принимает один параметр (x) и возвращает другую функцию.

Возвращаемая функция также принимает один параметр и добавляет его к переменной x.

Переменная x является частью замыкания. Когда переменная addThree2 объявляется в локальном контексте, ей назначается определение функции и замыкание. Замыкание содержит переменную x.

Так что теперь, когда addThree2 вызывается и выполняется, она имеет доступ к переменной x из своего замыкания и переменной n, которая была передана в качестве аргумента.
*/
let c4 = 4;
function addX2(x) {
  return function(n) {
    return n + x;
  }
}
const addThree2 = addX2(3);
let d2 = addThree2(c4);
console.log('example partial application', d2);

/* ||---------------------------------------------->> 
* Links:
* [✓][https://myrusakov.ru/javascript-closures.html] Область видимости и замыкания
* [][https://medium.com/nuances-of-programming/%D1%8F-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-3c3f02041970] О замыкании
* [✓][https://webdevblog.ru/ya-ranshe-nikogda-ne-ponimal-zamykaniya-v-javascript/] Та же статья про замыкания, но по-русски.
*/ 