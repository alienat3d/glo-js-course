'use strict';

// * === ООП - Наследование, прототипы, конструкторы и классы === * \\

// ? В программировании на JavaScript есть два подхода: функциональный и объектно-ориентированный.
// ? Функциональный подход — это когда мы пишем набор функций и используем их по необходимости.
// ? Объектно-ориентированный подход — это взгляд на программирование, что абсолютно всё является объектами. Это методика организации программы, структурирование сущностей и объединение сущностей и методов в единое целое. Его главный принцип заставляет программиста структурировать свой код, что очень полезно.

// ? JavaScript является прототипно-ориентированным языком программирования. У JS есть такое понятие "прототип" — это скрытая ссылка объекта. Прототип это объект (объект-шаблон), из которого текущий объект черпает недостающие свойства и методы.

// * 1.0 Рассмотрим на примере что такое прототипирование.
let arr = [1, 2, 3, 4, 5];

// console.dir(arr);

// 1.1 Чтобы использовать метод "join" интерпретатор обратился к прототипу, у которого он есть и который унаследовал объект с массивом arr. (Все эти свойства можно встретить, если полазить по дереву прототипов любого объекта в JS.)
// console.log(arr.join(', '));

// 1.2 А чтобы добраться, например, до метода "toString" интерпретатору пришлось углубиться на второй уровень прототипов, т.е. его унаследовал предыдущий прототип, у которого объект arr уже унаследовал методы и свойства.
// console.log(arr.toString());

// 1.3.0 Мы можем вывести и сам прототип в консоль. Для этого после названия нашего объекта "arr" поставим "." и как к свойству обратимся уже к прототипу.
// console.log(arr.__proto__);

// 1.3.1 Или даже к прототипу прототипа.
// console.log(arr.__proto__.__proto__);

// 1.4.0 Вспоминаем, что массивы можно создавать через конструктор Array. Это специальная функция-конструктор, которая наделяет определённый объект необходимыми свойствами и методами. Выведем прототип такого конструктора в консоль.
// console.log(Array.prototype);

// 1.4.1 Кстати, если мы сравним эти прототипы, то обнаружим, что они абсолютно одинаковы. А это значит, что когда создаётся массив, то он проходит через функцию-конструктор Array, которая наделяет его прототипом и таким образом все массивы наследуют свойства и метода от этого прототипа массивов.
// console.log(Array.prototype === arr.__proto__); // true

// * 2.0 = Пример объект-абстракция шаблона человека = * \\
const human = {
	hands: 2,
	legs: 2,
	eyes: 2,
	ears: 2,
	head: 1,
	belly: 1,
	walk: function () {
		console.log('Человек идёт');
	},
	talk: function () {
		console.log('Человек говорит');
	}
}

// 2.1 Создадим новый объект на основе объекта-шаблона. Аргументом в метод create() передадим объект-шаблон, служащий прототипом новому объекту.
const newGuy = Object.create(human);
const newGal = Object.create(human);

// console.log(newGuy); // на данный момент это просто пустой объект

// 2.2 Но вызвать эти методы мы всё таки смогли, хотя объект-то пустой. А произошло это потому, что у пустого объекта появилась ссылка на прототип (объект-шаблон), в котором эти методы присутствуют. Это значит, что ему присущи все характеристики прототипа, на основе которого он был создан. И если мы откроем вкладку [[Prototype]] или получим через console.log(newGuy.__proto__), то мы это увидим.
// newGuy.walk();
// newGuy.talk();

// 2.3 Однако добавим ему также уникальности
newGuy.name = 'Ivan';
newGuy.age = 30;

// 2.4 А также добавим ему ещё подружку, чтобы не было скучно :)
newGal.name = 'Maria';
newGal.age = 31;

// console.log(newGuy);
// console.log(newGal);

// Теперь мы получили уникальные объекты, которые однако построены на одном и том же прототипе и обладают общими одинаковыми наследованными свойствами и методами.

// * = Ещё один пример, но уже ближе к реальным задачам = * \\

// 3.0 Представим крупную компанию, у которой в штате есть множество должностей, но у всех них есть нечто общее, например, количество рабочих мест, кол-во обедов и методов "пришёл на работу", "ушёл с работы" и "занят работой".
const employee = {
	workplace: 1,
	dinner: 1,
	goToWork: function () {
		console.log('идёт на работу');
	},
	leaveWork: function () {
		console.log('уходит с работы домой');
	},
	working: function () {
		console.log('занят работой');
	},
}

// 3.1 Теперь, на основе объекта-шаблона создадим две профессии front-end dev & back-end dev.
const frontEndDev = Object.create(employee);
const backEndDev = Object.create(employee);

frontEndDev.role = 'Front-end Developer';
backEndDev.role = 'Back-end Developer';

// 3.2 Теперь мы имеем две уникальные профессии, но со всеми свойствами и методами объекта employee, от которого они всё унаследовали.
console.log(frontEndDev);
console.log(backEndDev);

// 3.3 Переопределим исходные значения метода working
frontEndDev.working = function () {
	console.log('Пишу качественный фронтэнд и пью кофе с печеньками :)');
};
backEndDev.working = function () {
	console.log('Мучаюсь с базами данных и серверным API, считаю себя лучшим программистом в компании.');
};

[с 11:40 дальше]

/* ||---------------------------------------------->> 
* Links:
* [][https://learn.javascript.ru/prototypes] Прототипы, наследование
* [][https://learn.javascript.ru/styles-and-classes#stroka-stiley-style-csstext] Стили и классы, getComputedStyle, cssText
*/ 