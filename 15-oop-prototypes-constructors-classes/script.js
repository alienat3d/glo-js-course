'use strict';

// * === ООП - Наследование, прототипы, конструкторы и классы === * \\

// ? В программировании на JavaScript есть два подхода: функциональный и объектно-ориентированный.
// ? Функциональный подход — это когда мы пишем набор функций и используем их по необходимости.
// ? Объектно-ориентированный подход — это взгляд на программирование, что абсолютно всё является объектами. Это методика организации программы, структурирование сущностей и объединение сущностей и методов в единое целое. Его главный принцип заставляет программиста структурировать свой код, что очень полезно.

// ? JavaScript является прототипно-ориентированным языком программирования. У JS есть такое понятие "прототип" — это скрытая ссылка объекта. Прототип это объект (объект-шаблон), из которого текущий объект черпает недостающие свойства и методы.

// * 1.0 Рассмотрим на примере что такое прототипирование.
let arr = [1, 2, 3, 4, 5];

// console.dir(arr);

// 1.1 Чтобы использовать метод "join" интерпретатор обратился к прототипу, у которого он есть и который унаследовал объект с массивом arr. (Все эти свойства можно встретить, если полазить по дереву прототипов любого объекта в JS.)
// console.log(arr.join(', '));

// 1.2 А чтобы добраться, например, до метода "toString" интерпретатору пришлось углубиться на второй уровень прототипов, т.е. его унаследовал предыдущий прототип, у которого объект arr уже унаследовал методы и свойства.
// console.log(arr.toString());

// 1.3.0 Мы можем вывести и сам прототип в консоль. Для этого после названия нашего объекта "arr" поставим "." и как к свойству обратимся уже к прототипу.
// console.log(arr.__proto__);

// 1.3.1 Или даже к прототипу прототипа.
// console.log(arr.__proto__.__proto__);

// 1.4.0 Вспоминаем, что массивы можно создавать через конструктор Array. Это специальная функция-конструктор, которая наделяет определённый объект необходимыми свойствами и методами. Выведем прототип такого конструктора в консоль.
// console.log(Array.prototype);

// 1.4.1 Кстати, если мы сравним эти прототипы, то обнаружим, что они абсолютно одинаковы. А это значит, что когда создаётся массив, то он проходит через функцию-конструктор Array, которая наделяет его прототипом и таким образом все массивы наследуют свойства и метода от этого прототипа массивов.
// console.log(Array.prototype === arr.__proto__); // true

// * 2.0 = Пример объект-абстракция шаблона человека = * \\
const human = {
	hands: 2,
	legs: 2,
	eyes: 2,
	ears: 2,
	head: 1,
	belly: 1,
	walk: function () {
		console.log('Человек идёт');
	},
	talk: function () {
		console.log('Человек говорит');
	}
}

// 2.1 Создадим новый объект на основе объекта-шаблона. Аргументом в метод create() передадим объект-шаблон, служащий прототипом новому объекту.
const newGuy = Object.create(human);
const newGal = Object.create(human);

// console.log(newGuy); // на данный момент это просто пустой объект

// 2.2 Но вызвать эти методы мы всё таки смогли, хотя объект-то пустой. А произошло это потому, что у пустого объекта появилась ссылка на прототип (объект-шаблон), в котором эти методы присутствуют. Это значит, что ему присущи все характеристики прототипа, на основе которого он был создан. И если мы откроем вкладку [[Prototype]] или получим через console.log(newGuy.__proto__), то мы это увидим.
// newGuy.walk();
// newGuy.talk();

// 2.3 Однако добавим ему также уникальности
newGuy.name = 'Ivan';
newGuy.age = 30;

// 2.4 А также добавим ему ещё подружку, чтобы не было скучно :)
newGal.name = 'Maria';
newGal.age = 31;

// console.log(newGuy);
// console.log(newGal);

// Теперь мы получили уникальные объекты, которые однако построены на одном и том же прототипе и обладают общими одинаковыми наследованными свойствами и методами.

// * = Ещё один пример, но уже ближе к реальным задачам = * \\

// 3.0 Представим крупную компанию, у которой в штате есть множество должностей, но у всех них есть нечто общее, например, количество рабочих мест, кол-во обедов и методов "пришёл на работу", "ушёл с работы" и "занят работой".
const employee = {
	workplace: 1,
	dinner: 1,
	companyName: '«WwW-Technologies Inc.»',
	goToWork: function () {
		console.log('идёт на работу');
	},
	leaveWork: function () {
		console.log('уходит с работы домой');
	},
	working: function () {
		console.log('занят работой');
	},
	sayHello: function () {
		console.log(
			'Привет, меня зовут ' +
			this.name +
			'. Я работаю в компании ' +
			this.companyName +
			' в должности ' +
			this.grade +
			' ' +
			this.role +
			'.'
		);
	}
}

// 3.1 Теперь, на основе объекта-шаблона создадим две профессии front-end dev & back-end dev.
const frontEndDev = Object.create(employee);
const backEndDev = Object.create(employee);

frontEndDev.role = 'Front-end Developer';
backEndDev.role = 'Back-end Developer';

// 3.2 Теперь мы имеем две уникальные профессии, но со всеми свойствами и методами объекта employee, от которого они всё унаследовали.
console.log(frontEndDev);
console.log(backEndDev);

// 3.3 Переопределим исходные значения метода working
frontEndDev.working = function () {
	console.log('Пишу качественный фронтэнд и пью кофе с печеньками :)');
};
backEndDev.working = function () {
	console.log('Мучаюсь с базами данных и серверным API, считаю себя лучшим программистом в компании.');
};

// 3.4 Добавим в компанию ещё несколько сотрудников-разработчиков
const developer1 = Object.create(frontEndDev);
const developer2 = Object.create(frontEndDev);
const developer3 = Object.create(backEndDev);
const developer4 = Object.create(backEndDev);

developer1.name = 'Al';
developer2.name = 'Alex';
developer3.name = 'Anton';
developer4.name = 'Roman';
developer1.grade = 'Junior';
developer2.grade = 'Middle';
developer3.grade = 'Senior';
developer4.grade = 'Junior';

// 3.5 [↑] В объект-прототип мы добавили метод sayHello(), выводящий в консоль строку-приветствие от лица каждого разработчика, пользуясь контекстом вызова и ключевым словом "this". Теперь запустим этот метод от каждого из них.
developer1.sayHello();
developer2.sayHello();
developer3.sayHello();
developer4.sayHello();

// 3.6 Теперь представим, что за хорошую работу всем фронтэнд-разработчикам увеличили кол-во обедов до 2-ух, исправить мы это можем очень просто, назначив, через прототип-фронтэнд-дев новое значение свойству dinner:
frontEndDev.dinner = 2;

console.log(developer1.dinner);
console.log(developer2.dinner);
console.log(developer3.dinner);
console.log(developer4.dinner);

// * = Методы для работы с объектами и прототипами = * \\

// * Метод 'hasOwnProperty'
// ? Аргументом в этот метод передаётся свойство, которое хотим проверить на наличие и если оно есть, то возвращается 'true', иначе 'false'. Проверяются именно их личные свойства, игнорируя прототипы.

console.log(developer1.hasOwnProperty('name')); // true
console.log(developer1.hasOwnProperty('role')); // false
console.log(developer1.__proto__.hasOwnProperty('role')); // true
console.log(developer1.__proto__.__proto__.hasOwnProperty('workplace')); // true

// * Метод 'isPrototypeOf()'
// ? Проверяет является ли один объект прототипом другого.

console.log(frontEndDev.isPrototypeOf(developer1)); // true
console.log(frontEndDev.isPrototypeOf(developer4)); // false

// * === Функция-конструктор === * \\

// ? 4.0 Функция-конструктор может быть незаменима, когда нам нужно создать очень много однотипных объектов. А сама функция-конструктор — это по сути любая функция, которая использует оператор "new" перед своим названием, чтобы создавать новые сущности.

// 4.1.0 Ведь, чем писать постоянно вручную множество однотипных объектов [...]
/* const person1 = {
	name: 'Jack',
}
const person2 = {
	name: 'John',
}
const person3 = {
	name: 'James',
} */
// 4.1.1 [...] намного удобнее будет создавать их через функцию-конструктор.
// ? Кстати, в JS принято называть функцию конструктор с большой буквы.
// ? 4.2 Сама функция-конструктор это просто описание будущих объектов, на основе которого они будут создаваться.
// ? 4.3.2 Возвращается "this" в тот объект, который был пустым, но которому функция-конструктор приписала новое свойство. И если мы будем передавать аргументы, то они будут попадать в параметры данной функции-конструктора и подставляться в качестве значений нужным свойствам. А затем [см. 4.3.1].
// ? 4.6.0 Мы можем указать методы и внутри функции-конструкторе. Теперь объект будет создан наделённым также и методом sayHello().
// ? 4.6.1 И метод уже будет лежать не в прототипе, а принадлежать новому объекту. Есть плюс и минусы данного подхода. 
// ? 4.6.2 Плюс: доступ к скрытым переменным. Создадим новую переменную возраста "age".
// ? 4.6.4 Минус: у каждого из создаваемых функцией-конструктором объектов будут методы, которые не будут равны. Это будут абсолютно разные методы. [...] ↓
const Person = function (name) {
	this.name = name;
	// 4.3.1 [...]
	// return this; — на самом деле под капотом JS возвращается из функции "this"

	const age = 37;

/* 	this.sayHello = function () {
		console.log('Всем привет! Меня зовут ' + this.name);
		console.log('Мне ' + this.age + ' года.');
	} */
}


// 4.3.1 Далее функция-конструктор возвращает объект и кладёт его в переменную, которую мы создали.
const person1 = new Person('Jack');
const person2 = new Person('John');
const person3 = new Person('James');

// 4.6.3 Если мы попробуем обратиться к этому свойству из-вне, то получим undefined. Она как бы скрыта от глаз, хотя её можно переопределить, как и любое другое свойство объекта.
// console.log(person1.age);

// ? 4.6.5 [...]
console.log(person1.sayHello === person2.sayHello); // false

// ? 4.6.6 При этом, когда мы создадим эти методы через прототип, то они будут одинаковы, т.к. они будут принадлежать прототипу. Т.е. мы не создаём этот метод каждый раз, а функция-конструктор передаёт наследование этим методом от прототипа. Метод принадлежит прототипу и поэтому у каждого объекта будет один и тот же унаследованный метод. (Представим, что мы создали тысячи объектов, на основании функции-конструктора, насколько же мы разгрузим память пользователя и выиграем в производительности!) Но мы также потеряем возможность использовать скрытые переменные внутри функции-конструктора.
// ? 4.6.7 А что если создать переменную внутри метода? Это можно, но это не лучшая практика, т.к. на прототип функции-конструктора может быть навешано очень много разных методов, зачастую они могут находиться в разных файлах. И искать переменные внутри метода будет неудобно.
// todo 4.6.8 Рекомендация от Ильясова: всегда вешать новые методы на прототип.

// ? Кстати, если мы не передадим в функцию-конструктор никаких аргументов, то она всё равно создастся, но только пустой и свойство "name" будет со значением "undefined".
const person4 = new Person;

// ? 4.3.0 Итак, когда интерпретатор считает слово "new", то в памяти JS создастся новый пустой объект, затем вызывается сама функция Person, а затем этому пустому объекту направляется контекст вызова "this". Далее этому объекту приписываются те свойства, которые мы описали в функции-конструкторе. Далее функция-конструктор возвращает новый объект. [см. ↑]

// 4.4.0 Для примера создадим обычный объект и сравним с объектом, созданным функцией-конструктором
const person5 = {
	name: 'Anna'
}
// 4.4 Теперь, если сравнить объекты, то мы заметим, что у объекта, созданного функцией-конструктором во вкладке [[Prototype]] есть не только [[Prototype]]: Object, но и свойство constructor. Зачем же нужна эта прослойка? В данный прототип мы можем добавить собственные методы.
console.log(person1);
console.log(person5);

// 4.5 Добавим функции-конструктору Person метод "sayHello()"
Person.prototype.sayHello = function () {
	console.log('Всем привет! Меня зовут ' + this.name);
}

person1.sayHello();
person3.sayHello();

console.log(person1); // теперь в прототипе всех объектов, созданных при помощи функции-конструктора появился метод sayHello();

// * == Специальные операторы для работы с прототипами == * \\

// ? 5.0 Как мы уже узнали выше, что при помощи метода "isPrototypeOf()" мы можем узнать является ли один объект прототипом другого объекта.
console.log(Person.prototype.isPrototypeOf(person1)); // true

// * Оператор "instanceof"
// 5.1 Но такое длинное обращение к прототипу выглядит громоздким и есть более короткий способ с помощью специального оператора "instanceof". По сути тоже самое, что и на строке 245.
console.log(person1 instanceof Person); // true

// * = Цепочка наследования = * \\

// ? 6.0 В языке JS подобные функции-конструкторы часто называют "классами". А всё происходящее при создании нового объекта: перенаправление контекста вызова на ново-созданный объект, принятие в ново-созданный объект всех свойств и методов из функции-конструктора, принятие прототипа в функции-конструктора в ново-созданный объект — чаще всего называют "наследованием".
// 6.1.1 Функция-конструктор это всего лишь абстракция, описание сущности. Представим сущность студента: всех студентов объединяет одно — они все студенты. Но у всех студентов разные имена. И само по себе имя должно присутствовать скорее в абстракции персоны. Поэтому мы создадим объект наследуясь от студента, который в свою очередь будет наследоваться от персоны (представим, что в объекте персоны расписаны характеристики человека и у него будет имя, вес, рост, возраст). А прототип студента, наследуясь от прототипа персоны получит все характеристики, но добавит свои (роль студента). И когда мы создадим новый объект студента по прототипу функции-конструктора студента, мы получим все данные характеристики. Для чего всё это нужно? Дело в том, что кроме студента, унаследовать характеристики персоны может, к примеру, работник. Т.е. будет две функции-конструктора "Student" & "Worker", и каждая из них унаследует свойства от прототипа Person. И получим в обоих случая человека, но каждая функция-конструктор следующего слоя будет накладывать свою роль, делая из него либо студента, либо работника.
// 6.1.3 А теперь, чтобы получить все характеристики объекта персоны мы применим метод "call()", который переопределит контекст вызова. Мы передадим в него контекст вызова "this", а также аргумент имени.
const Student = function (name, role) {
	Person.call(this, name);
	this.role = role;
}

// ? 6.1.2 Вспомним, как чуть ранее мы использовали Object.create() для связки двух разных сущностей. В данной ситуации мы можем поступить точно также — мы можем связать прототип студента и прототип персоны.
Student.prototype = Object.create(Person.prototype); // Здесь объект Student унаследовал свойства и методы от Person и теперь ему доступен метод "sayHello"
// 6.1.3 Создадим самому прототипа "Student" нет конструктора, давайте его создадим
Student.prototype.constructor = Student;
// 6.1.4 Теперь у "Student" и constructor "Student" & constructor "Person". Это и есть цепочка наследований: мы имеем прототип "Person", от которого наследуется прототип "Student", а от прототипа "Student" наследуется каждый новый студент.

// 6.1.0 Итак, я создал новую сущность, которая является прототипом функции "Student" и передал два аргумента "имя" и "роль".
const newStudent = new Student('Al', 'student');

console.log(newStudent);

/* ||---------------------------------------------->> 
* Links:
* [][https://learn.javascript.ru/prototypes] Прототипы, наследование
* [][https://learn.javascript.ru/styles-and-classes#stroka-stiley-style-csstext] Стили и классы, getComputedStyle, cssText
*/ 