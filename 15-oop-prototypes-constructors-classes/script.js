'use strict';

// * === ООП - Наследование, прототипы, конструкторы и классы === * \\

// ? В программировании на JavaScript есть два подхода: функциональный и объектно-ориентированный.
// ? Функциональный подход — это когда мы пишем набор функций и используем их по необходимости.
// ? Объектно-ориентированный подход — это взгляд на программирование, что абсолютно всё является объектами. Это методика организации программы, структурирование сущностей и объединение сущностей и методов в единое целое. Его главный принцип заставляет программиста структурировать свой код, что очень полезно.

// ? JavaScript является прототипно-ориентированным языком программирования. У JS есть такое понятие "прототип" — это скрытая ссылка объекта. Прототип это объект (объект-шаблон), из которого текущий объект черпает недостающие свойства и методы.

// * 1.0 Рассмотрим на примере что такое прототипирование.
let arr = [1, 2, 3, 4, 5];

// console.dir(arr);

// 1.1 Чтобы использовать метод "join" интерпретатор обратился к прототипу, у которого он есть и который унаследовал объект с массивом arr. (Все эти свойства можно встретить, если полазить по дереву прототипов любого объекта в JS.)
// console.log(arr.join(', '));

// 1.2 А чтобы добраться, например, до метода "toString" интерпретатору пришлось углубиться на второй уровень прототипов, т.е. его унаследовал предыдущий прототип, у которого объект arr уже унаследовал методы и свойства.
// console.log(arr.toString());

// 1.3.0 Мы можем вывести и сам прототип в консоль. Для этого после названия нашего объекта "arr" поставим "." и как к свойству обратимся уже к прототипу.
// console.log(arr.__proto__);

// 1.3.1 Или даже к прототипу прототипа.
// console.log(arr.__proto__.__proto__);

// 1.4.0 Вспоминаем, что массивы можно создавать через конструктор Array. Это специальная функция-конструктор, которая наделяет определённый объект необходимыми свойствами и методами. Выведем прототип такого конструктора в консоль.
// console.log(Array.prototype);

// 1.4.1 Кстати, если мы сравним эти прототипы, то обнаружим, что они абсолютно одинаковы. А это значит, что когда создаётся массив, то он проходит через функцию-конструктор Array, которая наделяет его прототипом и таким образом все массивы наследуют свойства и метода от этого прототипа массивов.
// console.log(Array.prototype === arr.__proto__); // true

// * 2.0 = Пример объект-абстракция шаблона человека = * \\
const human = {
	hands: 2,
	legs: 2,
	eyes: 2,
	ears: 2,
	head: 1,
	belly: 1,
	walk: function () {
		console.log('Человек идёт');
	},
	talk: function () {
		console.log('Человек говорит');
	}
}

// 2.1 Создадим новый объект на основе объекта-шаблона. Аргументом в метод create() передадим объект-шаблон, служащий прототипом новому объекту.
const newGuy = Object.create(human);
const newGal = Object.create(human);

// console.log(newGuy); // на данный момент это просто пустой объект

// 2.2 Но вызвать эти методы мы всё таки смогли, хотя объект-то пустой. А произошло это потому, что у пустого объекта появилась ссылка на прототип (объект-шаблон), в котором эти методы присутствуют. Это значит, что ему присущи все характеристики прототипа, на основе которого он был создан. И если мы откроем вкладку [[Prototype]] или получим через console.log(newGuy.__proto__), то мы это увидим.
// newGuy.walk();
// newGuy.talk();

// 2.3 Однако добавим ему также уникальности
newGuy.name = 'Ivan';
newGuy.age = 30;

// 2.4 А также добавим ему ещё подружку, чтобы не было скучно :)
newGal.name = 'Maria';
newGal.age = 31;

// console.log(newGuy);
// console.log(newGal);

// Теперь мы получили уникальные объекты, которые однако построены на одном и том же прототипе и обладают общими одинаковыми наследованными свойствами и методами.

// * = Ещё один пример, но уже ближе к реальным задачам = * \\

// 3.0 Представим крупную компанию, у которой в штате есть множество должностей, но у всех них есть нечто общее, например, количество рабочих мест, кол-во обедов и методов "пришёл на работу", "ушёл с работы" и "занят работой".
const employee = {
	workplace: 1,
	dinner: 1,
	companyName: '«WwW-Technologies Inc.»',
	goToWork: function () {
		console.log('идёт на работу');
	},
	leaveWork: function () {
		console.log('уходит с работы домой');
	},
	working: function () {
		console.log('занят работой');
	},
	sayHello: function () {
		console.log(
			'Привет, меня зовут ' + 
			this.name + 
			'. Я работаю в компании ' + 
			this.companyName + 
			' в должности ' + 
			this.grade + 
			' ' + 
			this.role + 
			'.'
		);
	}
}

// 3.1 Теперь, на основе объекта-шаблона создадим две профессии front-end dev & back-end dev.
const frontEndDev = Object.create(employee);
const backEndDev = Object.create(employee);

frontEndDev.role = 'Front-end Developer';
backEndDev.role = 'Back-end Developer';

// 3.2 Теперь мы имеем две уникальные профессии, но со всеми свойствами и методами объекта employee, от которого они всё унаследовали.
console.log(frontEndDev);
console.log(backEndDev);

// 3.3 Переопределим исходные значения метода working
frontEndDev.working = function () {
	console.log('Пишу качественный фронтэнд и пью кофе с печеньками :)');
};
backEndDev.working = function () {
	console.log('Мучаюсь с базами данных и серверным API, считаю себя лучшим программистом в компании.');
};

// 3.4 Добавим в компанию ещё несколько сотрудников-разработчиков
const developer1 = Object.create(frontEndDev);
const developer2 = Object.create(frontEndDev);
const developer3 = Object.create(backEndDev);
const developer4 = Object.create(backEndDev);

developer1.name = 'Al';
developer2.name = 'Alex';
developer3.name = 'Anton';
developer4.name = 'Roman';
developer1.grade = 'Junior';
developer2.grade = 'Middle';
developer3.grade = 'Senior';
developer4.grade = 'Junior';

// 3.5 [↑] В объект-прототип мы добавили метод sayHello(), выводящий в консоль строку-приветствие от лица каждого разработчика, пользуясь контекстом вызова и ключевым словом "this". Теперь запустим этот метод от каждого из них.
developer1.sayHello();
developer2.sayHello();
developer3.sayHello();
developer4.sayHello();

// 3.6 Теперь представим, что за хорошую работу всем фронтэнд-разработчикам увеличили кол-во обедов до 2-ух, исправить мы это можем очень просто, назначив, через прототип-фронтэнд-дев новое значение свойству dinner:
frontEndDev.dinner = 2;

console.log(developer1.dinner);
console.log(developer2.dinner);
console.log(developer3.dinner);
console.log(developer4.dinner);

// * = Методы для работы с объектами и прототипами = * \\

// * Метод 'hasOwnProperty'
// ? Аргументом в этот метод передаётся свойство, которое хотим проверить на наличие и если оно есть, то возвращается 'true', иначе 'false'. Проверяются именно их личные свойства, игнорируя прототипы.

console.log(developer1.hasOwnProperty('name')); // true
console.log(developer1.hasOwnProperty('role')); // false
console.log(developer1.__proto__.hasOwnProperty('role')); // true
console.log(developer1.__proto__.__proto__.hasOwnProperty('workplace')); // true

// * Метод 'isPrototypeOf()'
// ? Проверяет является ли один объект прототипом другого.

console.log(frontEndDev.isPrototypeOf(developer1)); // true
console.log(frontEndDev.isPrototypeOf(developer4)); // false

// * === Функция-конструктор === * \\

// ? 4.0 Функция-конструктор может быть незаменима, когда нам нужно создать очень много однотипных объектов. А сама функция-конструктор — это по сути любая функция, которая использует оператор "new" перед своим названием, чтобы создавать новые сущности.

// 4.1.0 Ведь, чем писать постоянно вручную множество однотипных объектов [...]
/* const person1 = {
	name: 'Jack',
}
const person2 = {
	name: 'John',
}
const person3 = {
	name: 'James',
} */
// 4.1.1 [...] намного удобнее будет создавать их через функцию-конструктор.
// ? Кстати, в JS принято называть функцию конструктор с большой буквы.
// ? 4.2 Сама функция-конструктор это просто описание будущих объектов, на основе которого они будут создаваться.

const Person = function (name) {
	this.name = name;
	// 4.3.1 [...]
	// return this; — на самом деле под капотом JS возвращается из функции "this"
}

// 4.3.1 Далее функция-конструктор возвращает объект и кладёт его в переменную, которую мы создали.
const person1 = new Person('Jack');
const person2 = new Person('John');
const person3 = new Person('James');

// ? Кстати, если мы не передадим в функцию-конструктор никаких аргументов, то она всё равно создастся, но только пустой и свойство "name" будет со значением "undefined".
const person4 = new Person;

// ? 4.3.0 Итак, когда интерпретатор считает слово "new", то в памяти JS создастся новый пустой объект, затем вызывается сама функция Person, а затем этому пустому объекту направляется контекст вызова "this". Далее этому объекту приписываются те свойства, которые мы описали в функции-конструкторе. Далее функция-конструктор возвращает новый объект. [см. ↑]

// 4.4.0 Для примера создадим обычный объект и сравним с объектом, созданным функцией-конструктором
const person5 = {
	name: 'Anna'
}
// 4.4 Теперь, если сравнить объекты, то мы заметим, что у объекта, созданного функцией-конструктором во вкладке [[Prototype]] есть не только [[Prototype]]: Object, но и свойство constructor. Зачем же нужна эта прослойка? В данный прототип мы можем добавить собственные методы.
console.log(person1);
console.log(person5);

// 4.5 Добавим функции-конструктору Person метод "sayHello()"
Person.prototype.sayHello = function () {
	console.log('Всем привет! Меня зовут ' + this.name);
}

person1.sayHello();
person3.sayHello();

console.log(person1); // теперь в прототипе всех объектов, созданных при помощи функции-конструктора появился метод sayHello();

// todo c [25:47]

/* ||---------------------------------------------->> 
* Links:
* [][https://learn.javascript.ru/prototypes] Прототипы, наследование
* [][https://learn.javascript.ru/styles-and-classes#stroka-stiley-style-csstext] Стили и классы, getComputedStyle, cssText
*/ 