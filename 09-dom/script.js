'use strict';

// * === DOM - Document Object Model === * \\

// ? DOM — это API (Application Programming Interface), по сути — это маленькая программа, которая с помощью, описанного в ней, набора методов и свойств сотрудничает с интерпретатором. В данном случае API DOM встроена в движок JS.
// ? API DOM создаёт слепок вёрстки и помещает его в объект. В объект помещается каждый тэг\элемент на странице, т.о. создавая древовидную структуру. Далее эта структура становится доступной внутри файлов JS через глобальный объект "document".
// ? Ответвления этой древовидной структуры называются "узлами" и они делятся на два типа: 1) узлы-элементы (все теги, которые представлены в вёрстке) и 2) простые узлы (всё, что не представлено в HTML, но находится внутри объекта).

// console.dir(document.childNodes); // Покажет непосредственные узлы объекта

// Кстати, интересно, что даже пустая строка или комментарий определится в DOM API как узел

// console.dir(document.body); // Покажет непосредственные внутренности тега body со всеми узлами

// * == Методы для работы с DOM API == * \\

// Получаем элемент заголовок по его уникальному id
const title = document.getElementById('title');

// Получаем элементы по тегу
const listItems = document.getElementsByTagName('li');

// Получаем элементы по классу
const listLinks = document.getElementsByClassName('link');

console.dir(title.textContent = 'DOM API'); // Получаем текстовое содержание элемента "title"
console.dir(title.style.textAlign = 'center'); // Получаем свойство с inline-CSS-стилями

// * Но пожалуй самые популярные это универсальные querySelector & querySelectorAll.

// Искать элементы можно по правилам CSS по разнообразным правилам. Найдём заголовок, например, по его атрибуту
const title2 = document.querySelector('[title="Document Object Model"]');
const headerList = document.querySelector('header > ul');

console.log(title2);
console.log(headerList);

// ? В отличии от querySelector, который получает один элемент (первый, который найдёт в вёрстке) querySelectorAll получает именно nodeList (или все элементы, подходящие под запрос в псевдо-массив). Кстати предыдущие методы "getElementsByTagName" & "getElementsByClassName" получают HTML-Collection (ещё называют «живая коллекция») и разница между двумя этими сущностями довольно весомая.

// ? В чём особенность «Живой коллекции»? К примеру: мы собрали на странице все ссылки с классом "link". Позже, мы создадим ещё один элемент и дадим ему класс «link» и добавим на страницу. Этот элемент сразу попадёт в переменную listLinks, т.е. в живую коллекцию. Потому она и зовётся "живой", т.к. она динамически обновляется новыми элементам, которые подпадают под её критерий.

// ? С точки зрения современного JS-стандарта «живые коллекции» устарели, поскольку держать в коде переменные, которые могут резко изменить своё содержимое считается ненадёжным и неправильным. Поэтому вместо "getElementsByTagName" & "getElementsByClassName" рекомендуется использовать более современный "querySelectorAll". Мы их рассмотрели лишь потому, что в старых проектах их до сих пор можно встретить.

const links = document.querySelectorAll('.link');

// ? Но почему же "getElementById" всё же до сих пор используют, если он такой старый? Всё дело в том, как он работает. "getElementById" остановится считывать вёрстку сразу же, как найдёт нужный id, ведь как известно id — уникален для каждой страницы и бывает лишь в 1 экземпляре, "querySelector" напротив считывает всю вёрстку. Это может чуточку замедлить, если вёрстка слишком длинная, хотя на практике это почти незаметно и рекомендуется не смешивать эти подходы для чистоты кода.

// ? А ещё, когда мы находим элементы при помощи "querySelectorAll", то мы получаем псевдо-массив nodeList, что добавляет нам полезные методы, например forEach(), что очень упрощает задачи перебора.

links.forEach(link => {
	console.log(link);
});

// * А ещё, с помощью "querySelector" & "querySelectorAll" мы можем искать в уже найденных элементах и помещённых в переменные, что чуточку ускорит наш код.
const list = document.querySelector('header > ul');
const listLinks2 = list.querySelectorAll('a');

console.log(listLinks2);

// * == Практика == * \\
const title3 = document.getElementById('title');

// * Работа с классами

// Добавим новый класс
title3.classList.add('green-color');

// Удалим класс
title3.classList.remove('title');

// Переключаем класс (если есть удаляем, если нет добавляем)
title3.classList.toggle('title');

// Метод "contains" проверяет наличие класса и если находит, то возвращает true, иначе false
console.log(title3.classList.contains('title'));

// * Работа с атрибутами

// Получение значения атрибута по его названию
console.log(title.getAttribute('title'));

// Изменение\задание атрибута: 1-ый параметр — задаём название атрибута, 2-ой — его значение
title.setAttribute('tooltip', 'It’s a title!')

// Проверка наличия какого-то атрибута на элементе: возвращает true или false
console.log(title.hasAttribute('tooltip'));

// * Работа со стилями

// При задании стилей важно помнить, что CSS-свойства в JS пишутся через camelCase. Заданные стили таким образом прописываются элементам инлайново, т.е. будут всегда приоритетными.
title.style.backgroundColor = 'gainsboro';

// Если нужно записать сразу несколько строк CSS-стилей, то сделать это можно с помощью свойства cssText
title.style.cssText = `
	background-color: ivory;
	color: indigo;
	font-size: 48px;
`;

// Также нам могут потребоваться уже применённые стили на каком-то элементе. Получить их можно при помощи свойства getComputedStyle. Это свойство доступно только для чтения, но бывает очень полезно прочитать какое-то свойство, чтобы отследить, что элемент как-то изменился и за этим должно последовать какое-то другое действие со стороны JS.
console.dir(getComputedStyle(title).fontSize);
console.dir(getComputedStyle(title).backgroundColor);

/* ||---------------------------------------------->> 
* Links:
* [][https://learn.javascript.ru/dom-nodes] Дерево DOM
* [][https://proglib.io/p/devtools-debug] Отладка кода
*/ 