'use strict';

// * === Делегирование событий === * \\

// ? Делегирование событий — это один из базовых паттернов работы с контентом.
// ? Паттерн — это некое шаблонное действие для решения часто встречающихся проблем при проектировании программы. Ну, а собственно паттерн "делегирование событий" направлен на уменьшение количества обработчиков событий на одной странице, что повышает производительность программы, приложения или сайта.

// * 1.0 Для начала напишем код без делегирования, для примера. Мы получим все 5 кнопок и по клику на каждой из них её textContent будет передаваться в большой блок ".text-block".
const buttonsBlock = document.querySelector('.buttons-block');
const output = document.querySelector('.text-block');
const addBtn = document.querySelector('#add-btn');

let btns = buttonsBlock.querySelectorAll('.btn');

const changeText = (text) => {
	output.textContent = text;
}

// * 2.0 Создадим новую функцию, которая будет добавлять новые кнопки. Во-первых, мы могли бы клонировать самую первую кнопку в nodeList'е "btns". И "true" мы не передаём, чтобы не делать глубокое копирование.
// 2.1 Далее нам нужно каждой новой кнопке указывать textContent, исходя из количества таких же кнопок. В этом нам пригодится свойство длинны псевдо-массива "length".
const addNewBtn = () => {
	const newBtn = btns[0].cloneNode();
	btns.length + 1 < 10 ?
		newBtn.textContent = `0${btns.length + 1}` :
		newBtn.textContent = `${btns.length + 1}`;
	buttonsBlock.append(newBtn);
	btns = buttonsBlock.querySelectorAll('.btn');
}

// 1.1 Пока что у нас на странице есть 5 кнопок, и на каждой из них висит один и тот же обработчик события, с одной и той же функцией. Но если мы станем добавлять новые кнопки?
// 3.4 Теперь у нас нет необходимости в обработчиках события на каждой кнопке, т.к. мы делаем это через делегирование из их родительского блока.
/* btns.forEach(btn => {
	btn.addEventListener('click', () => {
		changeText(btn.textContent);
	})
}); */

addBtn.addEventListener('click', () => {
	addNewBtn(); 1
});

// ? 3.0 Но получается, что чем больше у нас будет кнопок, тем больше будет и обработчиков события, но если кнопок станет слишком много, то это будет требовать от пользовательского устройства больших ресурсов, чтобы этого избежать и придумали паттерн "делегирование событий".
// 3.1 Для такой реализации мы повесим обработчик события на сам родительский блок, где функция обработчика получает evt (event), т.е. объект события, которое происходит на этом элементе. А event.target — цель самого события.
// ? 3.2 И если вспомнить тему "всплытия событий", то кликнув на дочернем элементе, оно также передаётся и родительскому и дальше вверх по иерархии элементов в DOM-дереве. Таким образом, можно повесить обработчик лишь на блок родителя, а потом проверять какой из его дочерних элементов был кликнут. И тогда, если мы убедимся, что он является кнопкой — активируем функцию changeText()/
// ? 3.3 Если рассмотреть объект event.target, то у него есть свойство tagName, именно по нему и можно проверять, что кликнутый элемент является кнопкой. ↑
// 3.5 На самом деле можно усовершенствовать этот функционал тем, что мы укажем, что если по клику в свойстве tagName будет что угодно, кроме "BUTTON", то функция просто закончится.
// 3.6 Как вариант, мы можем делать проверку не по HTML-тегу, а по классу при помощи метода contains().
// 3.7 Ещё нам доступен метод matches(), который принимает любые селекторы
// 3.8 Мы также могли бы повесить обработчик и на более верхний элемент по иерархии, если бы нам требовалось, чтобы включить в себя ещё больший спектр элементов, делая больше проверок по свойства event.target (например по event.target.id).
buttonsBlock.addEventListener('click', (evt) => {
	// if (!evt.target.tagName === 'BUTTON') return;
	// if (!evt.target.classList.contains('btn')) return;
	if (!evt.target.matches('button.btn')) return;
	changeText(evt.target.textContent);
})

// ? 4.0 Ещё у объекта event есть метод "closest()", который проверяет является ли event.target дочерним элементом какого-то другого блока. Удобно использовать как дополнительное уточняющее условие
// 4.1 В этом условии мы проверим, что целевой элемент является не только тегом "button", но и его родительский элемент имеет класс ".buttons-block", если там не нашёл, то он пойдёт дальше в своих поисках, вплоть до <html> и если у кого-то найдёт, то вернёт true.
if (evt.target.matches('button') && evt.target.closest('.buttons-block')) {
	changeText(evt.target.textContent);
}

// * 5.0 Паттерн делегирование событий нужен далеко не везде, он очень полезен и иногда даже необходим при работе с большим кол-вом однотипных элементов, которые ещё могут увеличиваться в огромном масштабе. Но не надо заходить с ним слишком далеко и обобщать с помощью делегирования слишком много элементов с разными задачами. Тем более, если они в одиночном варианте и увеличивать своё кол-во не собираются. Лучше повесить им отдельный обработчик и на этом успокоиться.


/* ||---------------------------------------------->> 
* Links:
* [][] 
*/ 