'use strict';

// * === Особенности современного стандарта ES6 === * \\

// * == Ключевые слова "let" & "const" == * \\

// ? 1.0 Стандарт ES6 (EcmaScript 6) был утверждён в 2015 году и принёс в язык очень много глобальных нововведений. (Например замена "var" ключевыми словам "let" & "const")

// * 1.1.0 Использование "var" может нести с собой множество проблем, т.к. оно записывает переменные в глобальную область видимости, в то время, как "const" & "let" только в свою область видимости.
// 1.1.1 Рассмотрим на примере двух циклов
// todo 1.1.2 Т.к. устаревшее ключевое слово "var" записывает переменную в глобальную область видимости (или в глобальный объект Window) и сразу выдаёт ей необходимое значение.
for (var index = 0; index < 5; index++) {
	setTimeout(() => {
		console.log(index);
	});
} // result: 5 [x5]
// 1.1.3 Тогда как ключевые слова "let" & "const" создают переменную исключительно в её области видимости. Т.о. при каждой итерации создаётся своя область видимости и значение переменной будет также для каждой итерации своё.
for (let index = 0; index < 5; index++) {
	setTimeout(() => {
		console.log(index);
	});
} // result: 0, 1, 2, 3, 4

// * 1.2.0 Естественно в предыдущем примере мы использовали ключ. слово "let" для создания изменяемый переменных, т.к. мы на каждой итерации цикла прибавляем +1 к её значению. Если бы мы создали через "const", то переопределить такое значение было бы невозможно.
// 1.2.1 Однако есть и с этим нюанс, если создадим с помощью ключ. слова "const" массив:
const array = [1, 2, 3, 'a', 'b'];

// 1.2.2 И не смотря на "const", в данный массив мы можем при помощи метода "push" добавлять новые значения
array.push(33);

console.log(array);

// * 1.2.3 Тоже самое и с объектами:
const object = {
	a: 1,
	b: 2,
	c: 3
}

object.d = 4;

console.log(object);

// * == Стрелочные функции == * \\

// * 1.3.0 Ещё одним нововведением ES6 являются стрелочные функции
// ? 1.3.1 Вспомним, что помимо более короткого синтаксиса они также не имеют собственного контекста вызова.

// 1.3.2 Создадим объект, в который перенесём описание функции и её вызов внутрь метода объекта "say".
// ? 1.3.3 На стрелочную функцию мы можем переписать также и метод объекта, удалив ключ. слово "function" и ":"
// 1.3.4 Теперь, если мы выведем контекст вызова в консоль, но получим объект, т.к. стрелочная функции для контекста вызова — словно решето и получает контекст вызова уровня выше, т.е. в данном случае контекст метода "say()".
// 1.3.5 Но стоит нам переписать внутреннюю функцию "sayMyNameNAge()" со стрелочной на обычную, то в консоль уже получим "undefined", т.к. вызов функции не относится ни к одному объекту. Он лишь вызывается внутри метода объекта, но при этом эта функция вызывается не через объект. Теперь внутри неё ключ. слово "this" контекста вызова пытается обратиться к глобальному объекту Window. Как раз этот важный момент меняет стрелочная функция.
// ? 1.3.6 Итак, если внутри объекта все методы будут описаны стрелочной нотацией — тогда проблем с контекстом вызова просто не возникнет. Ведь тогда в каждом методе контекст вызова будет ссылаться на сам объект. 
const user = {
	name: 'Kate',
	age: 38,
	// say: function () {
	say() {
		console.log(this);
		// const sayMyNameNAge = function(name, age) {
		const sayMyNameNAge = (name, age) => {
			console.log(this);
			console.log('Привет, меня зовут ' + name + '! Мне ' + age + ' лет.');
		};
		sayMyNameNAge(user.name, user.age);
	}
}

user.say();

// * 1.3.7 Получим картинку из вёрстки и повесим на клик по ней вызов метода 'say()' объекта 'user'.
const image = document.querySelector('img');

// 1.3.8 Теперь у нас контекстом вызова является сама картинка, по которой кликнули. Хотя вызывается метод объекта 'user', но обработчик события передаёт контекстом вызова тот объект, на котором произошло отслушанное событие.
// image.addEventListener('click', user.say);

// 1.3.9 Однако и здесь нам поможет стрелочная функция, т.о. мы получим объект как контекст вызова.
image.addEventListener('click', user.say);

// * == Значения по умолчанию в параметрах == * \\

// * 1.4 Со стандарта ES6 мы теперь также можем указывать значения параметров по умолчанию.

const human = (name, age = 33) => console.log('Этого человека зовут ' + name + ' и его возраст ' + age + '.');

human('Джэк', 25);
human('Джэк'); // если не передать второй аргумент, то подставится указанное значение по умолчанию

// * == Интерполяция (шаблонные строки) == * \\

// * 1.5.0 Теперь, используя интерполяцию, мы можем вместо такой функции...
// const sayMyNameNAge = (name, age) => {
// 	console.log('Привет, меня зовут ' + name + '!\n Мне ' + age + ' лет.');
// };

// 1.5.1 ...переписать её более лаконично:
// 1.5.2 Или даже внутри {} мы могли бы делать какие-то вычисления.
const sayMyNameNAge = (name, age, expAge) => {
	console.log(`Привет, меня зовут ${name}!
Мне ${age} лет. ${expAge} года я занимаюсь веб-разработкой, 
и когда я только начал мне было ${age - expAge} года.`);
};

sayMyNameNAge('Al', 37, 4);

// * == Классы == * \\

// ? 1.6.0 В уроке про функции-конструкторы мы уже столкнулись, что их часто именуют "Классы". Вспомним, что функция-конструктор это некая абстракция \ функция-шаблон, которая описывает будущий объект. Можно также вспомнить про наследование и как это могло сбить с толку. Когда одна абстракция наследует свойства и методы другой абстракции и когда мы выстраивали цепочку наследований — нам приходилось переопределять функции-конструкторы и прототипы. Но с выходом ES6 эта процедура была упрощена — было добавлено новое ключевое слово "class"

/* ||---------------------------------------------->> 
* Links:
* [][https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty] Object.defineProperty()
* [][http://jsraccoon.ru/es6-classes] ES6 классы
* [][https://learn.javascript.ru/private-protected-properties-methods#privatnoe-svoystvo-waterlimit] Приватные и защищённые методы и свойства
* [][https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/Public_class_fields] Поля классов ES6
*/ 