'use strict';

// * === Call Stack, контекст вызова "this" и Стрелочные функции === * \\

// * == Call Stack == * \\

// ? 1.0 Call Stack — это специальный механизм для интерпретатора, т.н. "контейнер для функции". Каждый раз, когда интерпретатор считывает функцию — он помещает её в особый контейнер. И уже внутри этого контейнера обрабатывает эту функцию. (Часто является одним из вопросов на собеседованиях.)

// 1.1 Для примера напишем 3 функции, две из которых будут вызывать другую функцию. 
// ? 1.2 Рассмотрим подробно как работает интерпретатор в браузере: мы вызвали первую функцию, которая вызвала вторую, вторая функция вызвала третью функцию и уже третья выдала нам в консоль сообщение. Когда вызывается функция firstFunc — она попадает в "Call Stack", где интерпретатор начинает считывать и запускать её код, как только он находит в ней запуск функции "secondFunc", то считывание функции "firstFunc" ставится на паузу и начинается считывание функции "secondFunc". Функция "secondFunc" также попадает в "Call Stack" и становится активной, начинается её выполнение. Теперь интерпретатор натыкается на вызов функции "thirdFunc" и уже функция "thirdFunc" попадает в "Call Stack" и становится активной, в то время как "secondFunc" и "firstFunc" стоят на паузе и ждут, пока выполнится третья "thirdFunc". Запускается код в функции "thirdFunc", запускающий вывод в консоль строки "Hello World!", после чего функция завершается и вылетает из "Call Stack", а интерпретатор возвращается к чтению функции "secondFunc", завершает её и тоже удаляет из "Call Stack". Затем переходит к "firstFunc", завершает и удаляет её из "Call Stack". В конце отрабатывания всех функций "Call Stack" становится таким же пустым, как и в самом начале.

// Для наглядности добавим вывод в консоль старта и окончания каждой функции
// ? Для ещё большей наглядности мы можем воспользоваться вспомогательным инструментом "debugger", для этого пропишем в тех местах, где мы хотим остановить и рассмотреть в подробностях (через Dev Tools) функционал ключевое слово "debugger;". Теперь мы можем в режиме debugging Dev Tools в браузере отследить пошагово выполнение всех функций. Это очень полезный инструмент, однако в JS у нас есть также console.log(), которым чаще бывает проще и быстрее себя проверить. 
const firstFunc = function () {
	// debugger;
	console.log('start of firstFunc');
	secondFunc();
	// debugger;
	console.log('end of firstFunc');
}
const secondFunc = function () {
	// debugger;
	console.log('start of secondFunc');
	thirdFunc();
	// debugger;
	console.log('end of secondFunc');
}
const thirdFunc = function () {
	// debugger;
	console.log('start of thirdFunc');
	console.log('Hello World!');
	console.log('end of thirdFunc');
}

// debugger;
// firstFunc();
// debugger;

// * В языке JS есть возможность отложенного запуска функции через метод setTimeout().
// ? Этот метод получает два обязательных аргумента: 1) название функции, которую запустит данный метод (прописываем без "()", т.к. за вызов будет отвечать сам "setTimeout" по истечении времени), 2) кол-во миллисекунд, по истечении которых запустится функция из первого аргумента (1000 мс = 1 с).

// setTimeout(thirdFunc, 2000); // ? она сработает через 2 секунды, даже, если будет стоять перед какой-то функцией в коде, которая запускается сразу.

const test = function () {
	console.log('test');
}

// ? Но даже, если мы укажем таймаутом "0", то она запустится всё равно после другой функции, которая запускается сразу. Это происходит потому, что кроме контейнера "Call Stack" есть ещё несколько других контейнеров, например, контейнер отложенных функций. Так, интерпретатор, натыкаясь на метод setTimeout помещает функцию "thirdFunc" не в "Call Stack", а сперва в контейнер для отложенных функций, после чего он начинает выполнять весь код в "Call Stack", который не относится к отложенным. И только, когда все функции в "Call Stack" будут прочитаны и запущены, то интерпретатор перейдёт к отложенным функциям и перенесёт их в "Call Stack".
// setTimeout(thirdFunc, 0); // Выполнится после test();
// test();

// * Чего в этом случае стоит опасаться, так это — рекурсии. Для демонстрации рассмотрим этот случай:
// todo /!\ Это может переполнить "Call Stack" и подвесить браузер.
/* const thirdFuncRecursive = function () {
	console.log('Hello World!');
	setTimeout(thirdFuncRecursive, 0);
} 
thirdFuncRecursive();
*/

// * == Контекст вызова "this" == * \\

// ? По сути контекст вызова "this" — это ссылка на объект, в котором он вызван. Он не связан с областью видимости.
// ? В языке JavaScript каждый раз, когда мы вызовем функцию или метод, интерпретатор вызову данной функции или методу подпишет несколько важных свойств, делая это внутри своего движка. Доступа к этим свойствам у нас нет, но контекст вызова формируется на основе этих свойств. К примеру, первым свойством будет объект-инициатор вызова данной функции. Т.е. что именно заставило эту функцию быть вызванной. Вторым свойством будет свойство внутри этого объекта, в котором находится эта функция. Третьим свойством будет булево значение, используем ли мы "строгий режим".
// ? Так что же такое "объект-инициатор" вызова функции из первого свойства на примере функции "one"? В данном примере в консоль у нас выводится "undefined" (не определено), т.к. сама функция "one" не принадлежит ни одному объекту, поэтому и контекста вызова у неё нет. Но если мы уберём строгий режим и const заменим на var, то её контекстом вызова станет глобальный объект Window и теперь мы можем запустить эту функцию, как метод этого объекта, т.к. она будет прописана в него. Именно объект Window стал "объектом-инициатором" функции "one".

// console.log(this); // получим глобальный объект "Window"

// ? Если бы мы не пользовались "строгим режимом" (use strict в начале кода), то мы получили также объект Window в консоль. На самом деле это очень полезно, в строгом режиме у функции нет доступа к глобальному объекту Window, а значит мы не сможем как-то случайно изменить его.
/* var one = function () {
	console.log(this);
}

window.one(); */

// * Создадим два объекта пользователей и посмотрим как контекст вызова "this" будет себя вести внутри них

// Конечно в данном случае можно было обойтись и без контекста вызова, обращаясь к объекту.
const user1 = {
	name: 'Al',
	/* say: function () {
		// console.log('Hello, ' + this.name);
		console.log('Hello, ' + user1.name);
	} */
	say: sayName
}

const user2 = {
	name: 'Ketie',
	/* say: function () {
		// console.log('Hello, ' + this.name);
		console.log('Hello, ' + user2.name);
	} */
	say: sayName
}
// Но что, если описание этой функции было бы вне объектов, например:
// Здесь нам уже просто необходимо указать контекст вызова перед названием свойства, т.к. мы заранее не знаем какой из объектов будет инициатором запуска. Т.о. она становится универсальной.
function sayName(a, b) {
	// console.log(a + b);
	console.log(this.name);
}

// Как не трудно заметить каждый метод ссылается на свой объект, т.к. он указан при вызове одноимённых методов.
// todo /!\ Важно: Контекст вызова формируется в момент вызова функции. Подобное формирование контекста вызова называется "неявная привязка".
// user1.say();
// user2.say();

// ? Но также существует такое понятие, как "явная привязка", т.е. мы может сами указывать JS какой контекст нужно привязать к определённой функции.
// * Методы "call()" & "apply()"
// ? Помимо самого объекта-инициатора вызова, могут принимать в себя и другие аргументы. Добавим аргументы "1" & "2" и выведем в консоль их сумму.
// ? Также следует помнить, что данные вызовы сразу же вызывают функцию с указанным контекстом вызова.
// Но в современном JS использование этих методов можно встретить довольно редко, в отличии от метода "bind".

// Если мы попытаемся вызвать функцию саму по себе, то получим ошибку, т.к. JS не может найти контекст вызова, а также нет свойства "name". Но мы можем использовать один из двух методов "call()" & "apply()", которые вызовут эту функцию с заданным нами контекстом вызова.
// sayName.call(user1, 1, 2);
// ? Метод "apply" принимает аргументы несколько иначе, он принимает лишь 1 второй аргумент в виде массива.
// sayName.apply(user2, [1, 2]);

// * Метод "bind()"
// ? Если предыдущие методы "call()" & "apply()" называют "явной привязкой контекста", то метод "bind" — "фиксированная привязка контекста вызова функции".

// Продемонстрируем его работу на новой переменной, куда поместим функцию sayName, которую методом "bind" привяжем к нужному контексту вызова.

const sayKetie = sayName.bind(user2);
const sayAl = sayName.bind(user1);

// sayKetie();
// sayAl();

// * == Практика контекста вызова в функциональном программировании. А также немного о том, как он может ломаться == * \\
const buttons = document.querySelectorAll('button');

const user = {
	name: 'Peter',
	say: function () {
		console.log(this.name);
		// 2.1 Здесь контекстом вызова является кнопка
		console.log(this);
	}
}
// * 2.0 На первый взгляд кажется, что при клике мы должны получить имя "Peter" в консоль? Но не всё так просто, с обычной функцией мы получим пустую строку.
// 2.2.0 На самом деле так происходит из-за особенностей работы метода "addEventListener" — он получает user.say внутрь себя, обрабатывает и самостоятельно вызывает данную функцию при клике на кнопку. Т.о. инициатором запуска будет сам объект кнопки.
buttons.forEach(function (button) {
	button.addEventListener('click', user.say);
	// 2.2.1 Это можно увидеть через свойство "onclick". Там мы увидим лишь саму функцию say(), которая ничего не знает про объект вызова. Т.е. она была скопирована и помещена в свойство "onclick". И по событию запустится функция от имени самого объекта button. И в функциональном программировании это не редко используется.
	button.onclick = user.say;
	// console.dir(button);
});

// 2.3.0 Напишем функцию, которая будет менять свойство border на красный цвет.
const changeBorderColor = function (evt) {
	// 2.3.1 Также мы можем перебрать все кнопки и удалить у всех них красное обрамление
	buttons.forEach(button => {
		button.style.border = '2px solid black';
	});
	// 2.3.2 Так контекст вызова "this" может быть полезным и в самом обычном функциональном программировании. 
	// this.style.border = '2px solid red';
	// 2.3.3 Хотя в этом случае легче было бы воспользоваться свойством event.target, добившись такого же эффекта, но event.target точно не потеряется, как может случиться с контекстом вызова.
	evt.target.style.border = '2px solid red';
}

buttons.forEach(function (button) {
	button.addEventListener('click', changeBorderColor);
});

// * = Потеря контекста вызова = * \\

const userName = {
	name: 'Jack',
	say: function () {
		console.log(this.name);
	}
}

// userName.say();

// 3.0 Пока всё работает хорошо, но что, если мы запустим этот метод через setTimeout?

// setTimeout(userName.say, 2000); // получаем пустую строчку

// ? 3.1 Дело в том, что перед запуском функции метод say() был помещён в отдельный контейнер отложенных функций, а уже после интерпретатор поместил его в "Call Stack" (см. предыдущую тему выше ↑), после чего данный метод запускается от имени глобального объекта Window.
// 3.2 Но на этот случай у нас есть решение, мы можем вызвать этот метод внутри анонимной функции
// setTimeout(function () {
// 	userName.say();
// }, 2000);

// * == Стрелочные функции == * \\

// ? У такого типа функций есть пара интересный нюансов: 1) возможность более короткой записи; 2) отсутствие своего контекста вызова.

// * 4.0 Для примера, напишем простую стрелочную функцию, которая будет складывать два числа. (Числа мы передадим в параметры "a" & "b".)

/* const addition = (a, b) => {
	return a + b;
} */
// 4.1 Или мы можем записать её ещё более короче, т.к. она содержит лишь 1 строку кода:
const addition = (a, b) => a + b;

console.log(addition(1, 2));

// 4.2 А если функция принимает один параметр, то можно избавиться также и от круглых скобок!
const multiplyBy10 = a => a * 10;

console.log(multiplyBy10(3));

// 4.3 
const obj = {
	array: [1, 2, 3, 4],
	someFunc: function () {
		console.log(this); // получаем объект с массивом array
		// this.array.forEach(function (item) {
		this.array.forEach((item) => {
			console.log(this); // получаем "undefined", потому, внутри перебора работает ещё одна функция, а у каждой функции свой контекст вызова и внутри это функции контекст вызова сбился. Но мы можем его вернуть, если используем вместо обычного function expression используем стрелочную функцию, у которой нет собственного контекста вызова. И тогда наш объект с массивами снова вернулся и функция работает как надо.
			console.log(item);
		})
	}
}

obj.someFunc();

// ? Стрелочные функции настолько полюбились программистам, что появилось даже маленькое негласное правило: «если контекст вызова не важен — используй стрелочную функцию».

// * Есть ещё один нюанс, связанный со стрелочными функциями — в тех случаях, когда стрелочная функция возвращает всего лишь 1 объект и больше не делает никаких действий, то мы можем также сократить код, избавившись от "return" и заключив возвращаемый объект в "()"
// Было
/* const func = () => {
	return {
		name: 'Alex',
		city: 'Minsk'
	}
} */
// Стало
const func = () => ({
	name: 'Alex',
	city: 'Minsk'
})

console.log(func());

/* ||---------------------------------------------->> 
* Links:
* [][https://medium.com/webbdev/js-a4a9dfed9782] Контекст выполнения и стек вызовов в JavaScript
* [][https://habr.com/ru/articles/515356/] Как работает this
* [][https://habr.com/ru/post/199456/] Bind, Call и Apply
* [][https://learn.javascript.ru/arrow-functions-basics] Функции-стрелки, основы
*/ 