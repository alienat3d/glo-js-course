// * === Переменные и типы данных === * \\
// В основном по дефолту используем const для обозначения переменных, которые не будут изменяться, для особенных, которые всё таки будут — используем let.

// Есть 7 скалярных типов данных (примитивов)
const num = 5; // цифры
const floatingPointNum = 5.05; // цифры с плавающей точкой
// const floatingPointNum = .05; // альтернативная запись цифры с плавающей точкой
// ? Также числа могут быть записана в трёх других системах исчисления:
console.log(0xff); // 255 в шестнадцатеричной системе
console.log(0b11111111); // 255 в бинарной системе
console.log(0o377); // 255 в восьмеричной системе

const str = 'Hello world!'; // строка
let bool = true; // булево значение принимает либо true, либо false
let und; // undefined (это значение мы почти никогда сами не присваиваем, но его присваивает сам JS, когда не может найти какое-то значение, к которому мы обращаемся)
const bigInt = 25002195224663795n; // целые большие числа > 2^53 (ведь в обычных цифрах это максимальное число, как для +, так и для - значений). У таких чисел в конце стоит "n". Однако не может быть применён для чисел с плавающей точкой.
const symbol = Symbol(); // уникальные неизменяемые данные (используется крайне редко)

let donutHole = null; // специальный примитив (пустое значение, которое, в отличии от undefined, используют разработчики, которые например задают какую-то переменную, но пока в ней никакого значения не требуется, но в будущем оно будет, либо наоборот, когда им нужно избавиться от данных, то их можно перезаписать null'ом)

// Также есть структурные типы данных
let object = {
	a: 5,
	b: 'javascript',
	c: false,
	d: {
		a: 10,
		b: 15
	},
	e: [1, 2, 3]
}; // объект
console.log(object.d);
console.log(object['e']);
object.e = [4, 5];
console.log(object['e']);
object.names = ['Kate', 'Al'];
console.log(object);
object = null;
console.log(object);


const array = [1, 'b', {a: 2, b: 'hello'}, true]; // массив (разновидность объекта)
console.log(array[2]);

// Функции в различном написании
const func1 = function () {}; // функции
const func2 = () => {}; // функции

// Специальные объекты
const obj = new Object();
const regExp = new RegExp(); // регулярные выражения
const regExp2 = /D/g; // регулярные выражения в иной записи
const error = new Error(); // ошибки
const date = new Date(); // для работы с датами

// 2 коллекции
const map = new Map();
const set = new Set();

const weakMap = new WeakMap();
const weakSet = new WeakSet();

// Для определения типа данных есть унарный оператор typeof. Унарный значит, что он содержит один операнд. Возвращает строку с описанием определённого типа данных.
console.log(typeof bigInt);

// * == Операторы == * \\
// ? Унарные плюс и минус используются для преобразования строк в число (положительное и отрицательное).
console.log(+5);
console.log(-5);

// Также существуют операторы инкремента и декремента
let i = 5;

console.log(i++); // +1 после вывода значения
console.log(++i); // +1 перед выводом значения (т.к. перед этим был уже 1 инкремент, то следовательно +2)

let j = 10;

console.log(j--); // -1 после вывода значения
console.log(--j); // -1 перед выводом значения (т.к. перед этим был уже 1 декремент, то следовательно -2)

// ? Также в JS есть следующие математические операторы

console.log(10 + 5);
console.log(10 - 5);
console.log(10 / 5);
console.log(10 * 5);

console.log(10 ** 5); // Возведение в степень
console.log(10 % 3); // Модуль (остаток от деления)

// ? Есть и простая арифметика с присваиванием

let n = 1;

n = n + 9;

console.log(n);
// Тоже самое, что
n += 9;

console.log(n);

n -= 2;
console.log(n);
n *= 2;
console.log(n);
n /= 2;
console.log(n);
n **= 2;
console.log(n);
n %= 2;
console.log(n);

// ? Операторы сравнения

console.log(3 > 2);
console.log(3 < 2);
console.log(7 >= 4);
console.log(7 <= 4);

console.log(10 == 10);
console.log(10 == '10');
console.log(10 != 10);
console.log(10 != 11);
console.log(10 != '11');

// Строгое сравнение, где сравниваются не только значения, но и тип данных
console.log(10 === 10);
console.log(10 === '10');
console.log(10 !== 10);
console.log(10 !== 11);
console.log(10 !== '11');

// * == Объект Math == * \\
// Для более сложный математический операций
console.log(Math.floor(3.456)); // округление в меньшую сторону
console.log(Math.ceil(3.456)); // округление в большую сторону
console.log(Math.round(3.456)); // округление до ближайшего числа
console.log(Math.trunc(3.456)); // удаление дробной части (может не поддерживаться старыми браузерами)

console.log(Math.random()); // генерирует случайное число от 0 до 1
console.log(Math.max(3, 5, 8)); // возвращает самое большое число из попавших в него
console.log(Math.min(3, 5, 8)); // возвращает самое маленькое число из попавших в него
console.log(Math.sqrt(25)); // возвращает корень числа
console.log(Math.pow(3, 2)); // возводит число в степень, аналог "3 ** 2"

// * == Работа со строками == * \\
const greeting = "Hello world!";
const anotherGreeting = 'Hello world!';

// ? В кавычках одного вида не могут быть кавычки такого же вида, либо их нужно "экранировать", либо заменить на другой вид кавычек.
// ? Также есть спецсимволы \t - табуляция и \n - перенос строки. 
const someStr = "\t Это был Эдвард \"Чёрная борода\" Тич, и не было в мире пирата,\n способного конкурировать по популярности с этим человеком."

console.log(someStr);

// ? Есть и оператор конкатенации "+"
const newStr = someStr + "\n Этот пират был настоящей грозой морей до начала 18-го века."

console.log(newStr);

// * == Популярные методы для работы со строками == * \\
const froggySays = "It’s wednesday, my dudes...";

console.log(froggySays.length); // получение длины строки (кол-во символов)
console.log(froggySays.toLowerCase()); // привести все символы к нижнему регистру
console.log(froggySays.toUpperCase()); // привести все символы к верхнему регистру
console.log(froggySays.charAt(10)); // [dep.] получение символа по его порядковому номеру (индексу) в строек
// ? Правда есть аналогичный более лаконичный способ получить символ по индексу, который чаще всего и используют.
console.log(froggySays[2]);

// * == Получение куска строки == \\
console.log(froggySays.substring(5)); // Возвращает строку, начиная с этого символа включительно
console.log(froggySays.substring(5, 14)); // Возвращает строку, начиная с символа (1 параметр) и заканчивая символом предыдущего индекса (2 параметр)
// ? slice() работает аналогично substring() и у него также два параметра, 1 обязательный и 1 опциональный, но у него есть один нюанс — он также может принимать отрицательные значения и возвращать символы, начиная с конца строки.
console.log(froggySays.slice(5, 14));
console.log(froggySays.slice(-8));

// Похож на substring(), но 1 параметр — откуда он начнёт резать строку, а 2 — сколько символов надо забрать.
console.log(froggySays.substr(5, 9)); // [dep.] устаревший аналог substring()

// * == Поиск в строке == \\
// Проходится по строке и ищет совпадение, затем возвращает индекс, где нашёл совпадение. Можно передать как один символ, так и целую строку.
console.log(froggySays.indexOf('my')); // 16, т.к. индексом литеры "m" в этой строке является 16.
console.log(froggySays[16]);

// Чем-то похож на indexOf(), также проходится по всей строке, но возвращает либо false, либо true, если нашёл совпадение или нет, соответственно.
console.log(froggySays.includes('dudes'));
console.log(froggySays.includes('girls'));

// Принимает 2 параметра: Пройдётся по всей строке в поисках совпадений с первым параметром и если такие совпадения будут обнаружены — он заменит это совпадение вторым параметром.
console.log(froggySays.replace('dudes', 'gals'));

// Принимает 1 параметр: в него можно передать 1 или целую строку. Далее всё это преобразуется в массив, в котором при каждом совпадении строка будет разрезана на элемент этого массива.
// Например, в нашей строке имеем 3 пробела и если указать параметром пробел, то эта строка будет разделена на 3 элемента массива. И ни в одном не будет этого пробела.
console.log(froggySays.split(' '));
// Или ещё один эксперимент для закрепления с буквой "е".
console.log(froggySays.split('e'));
// ? В JS довольно часто встречаются задачи, где требуется работать со строками (например полученные данные с сервера в виде строки), в которых много слов, разделённых "," и тогда их очень удобно разрезать на элементы массива подобным образом.
let usCompanies = 'Apple, IBM, Google, SpaceX, Yahoo';

console.log(usCompanies.split(', '));

/* ||---------------------------------------------->> 
* Links:
* [Типы данных] https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures
* [Числа] https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number
* [Строки] https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String
* [Выражения и операторы] https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators
* [Условный (тернарный) оператор] https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80
*/ 