'use strict';

// * === Динамическая типизация данных в Javascript. Условия, ветвления. === * \\

// ? Мы уже рассмотрели два метода, для вывода информации пользователю alert() и разработчику console.log(), но что, если нам нужно будет, чтобы пользователь мог ввести какую-то информацию для обработки? Для двустороннего общения пользователя с сайтом есть два метода confirm() и prompt().
// * Рассмотрим метод confirm()
// Данный метод выведет модальное окно с 2-умя кнопками "ОК" и "Отмена", в случае нажатия на "ОК" — выведет true, в случае с "Отмена" — false. Т.е. ответ придёт булевым значением.
/* const answer = confirm('Вам уже исполнилось 18 лет?');

console.log(answer); */

// * Рассмотрим метод prompt()
// Данный метод выведет также, как и с confirm() модальное окно с двумя кнопками, но также и со строкой ввода, где пользователь может ввести свой ответ. Также опционально вторым атрибутом можно указать значение по умолчанию. Ответ придёт в виде строки. 
// todo Однако, если пользователь вместо ответа нажмёт "Отмена", то в переменную userAge попадёт "null". Это стоит всегда учитывать при разработке, чтобы такое действие не поломало выполнение скрипта.
/* const userAge = prompt('Сколько вам лет?', 'Напишите только цифры');

console.log(userAge); */

// * ======================================= * \\
// ? JavaScript — это язык с динамическим приведением типов данных. Это означает, что когда интерпретатор, считывая наш код, натыкается на выражение, которое он не может сразу разрешить, т.е. операнды имеют разные типы данных, то он обязательно попробует привести тип данных одного операнда к типу данных другого, чтобы выражение было возможно разрешить. 

// В данном случае интерпретатор видит знак конкатенации и он переведёт число в строку и склеит две строки и в итоге мы получим 55 в виде строки.
console.log(5 + '5');

// А что же будет в случаях с другими математическими операторами? Интерпретатор увидит, что мы хотим вычитать, умножать или разделить и приведёт строковый тип данных к числовому и выполнит математическую операцию. 
// ? Такое преобразование данных называет "не явное преобразование".
console.log(5 - '5');
console.log(5 * '5');
console.log(5 / '5');

// Но если интерпретатор не сможет перевести строку в числовое значение, как в данном примере, то выдаст "NaN" (Not a Number).
console.log(5 / '5a');

// Также интерпретатор поведёт себя и с операторами строгого сравнения, выдаст false, увидев разные типы данных
console.log(5 == '5');
console.log(5 === '5');

// ? В JS существуют и явные преобразования типов данных, когда разработчик целенаправленно изменяет тип данных. Для этого есть несколько инструментов.
// * 1 — Глобальные методы:
// * Глобальный метод String переведёт всё, что попадает в него в строчный тип данных
console.log(String(true));
console.log(String(undefined));
console.log(String(null));
console.log(String('123'));
console.log(String(123));

// * Глобальный метод Number переведёт всё, что попадает в него в числовой тип данных
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(undefined)); // NaN
console.log(Number(null));  // 0
console.log(Number('123')); // 123
console.log(Number('123abc')); // NaN (не может быть переведена в число, т.к. имеет буквы)
console.log(Number(123)); // 123

// * Глобальный метод Boolean переведёт всё, что попадает в него в булево значение
// ? Следующие 5 значений Boolean() вернёт как ложь, потому, что они интуитивно отсутствуют или являются пустыми.
console.log(Boolean(undefined)); // false
console.log(Boolean(null)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(false)); // false
console.log(Boolean('')); // false
// Все остальные значение возвращаются как "true"
console.log(Boolean('123')); // true
console.log(Boolean(' ')); // true
console.log(Boolean('123abc')); // true
console.log(Boolean(123)); // true

// ? Также в булево значение можно перевести, используя унарный оператор "двойное отрицание" ("!!"). Он более предпочтителен, т.к. более компактный, а работает точно также, как и Boolean().
console.log(!!5);

// * Перевод чисел в строки
console.log(typeof (555 + ""));

// Ещё один вариант для перевода

// console.log(10 .toString()); // довольно костыльный метод, поэтому лучше воспользуемся переменной

const a = 10;

console.log(a.toString()); // довольно широко используется

// * Перевод строки в число
// Если мы добавим строке унарный плюс, заставляя её становиться числом, то она превратится в число. Однако для корректной работы в строке действительно должны быть только цифры, иначе получим NaN
console.log(+'5');

// * ======================================= * \\

// * Примеры * \\
// Для перевода ответа сразу в число мы также можем использовать унарный оператор.
/* const str = +prompt('Сколько вам лет?');

const result = str + 10;

console.log(result); */

// ? Однако, если пользователь введёт пробелы или буквы, то результатом у нас будет NaN, это нужно также продумать.
// * Здесь нам помогут parseInt() & parseFloat()
// const digits = prompt('Сколько вам лет?');

// * parseInt() пробегается по всей строке возвращает только числовые значения.
// todo Но есть нюанс, если пользователь введёт только буквы, либо первой будет буква, то мы получим NaN. 
// console.log(parseInt(digits));

// Также, если число будет дробное, то он вернёт нам только целочисленное значение. Для работы с дробными числами есть метод parseFloat()
// console.log(parseFloat(digits));

// * У метода parseInt() есть также второй опциональный параметр, с помощью которого мы можем указывать в какой системе счисления мы хотим получить результат.
console.log(parseInt('10ff', '2'));
console.log(parseInt('10ff', '8'));
console.log(parseInt('10ff', '16'));

// * ======================================= * \\

// * Условия и ветвление * \\

if (true) console.log('Истина');
if (false) console.log('Ложь'); // со значением false никогда не будет выполнено

// ? Но всё же предпочтительнее писать в кавычках, даже если однострочный код

if (true) {
	console.log('Выполнена команда 1');
	console.log('Выполнена команда 2');
	console.log('Выполнена команда 3');
}

// Если нам нужно также указать команды, которые будут выполнены в случае, если значение вернёт 'false', то используем оператор 'else'.
if (false) {
	console.log('Выполнена команда 1');
	console.log('Выполнена команда 2');
	console.log('Выполнена команда 3');
} else {
	console.log('Выполнена команда 4');
	console.log('Выполнена команда 5');
	console.log('Выполнена команда 6');
}

// ? Если команда всего одна, то хорошо заменяемо при помощи тернарного оператора.
if (true) {
	console.log('Выполнена команда 1');
} else {
	console.log('Выполнена команда 2');
}

const c = 5;

c > 6 ? console.log('Выполнена команда 1') : console.log('Выполнена команда 2');

// --- \\

const b = 7;

if (b >= 8) {
	console.log('Выполнена команда 1');
} else if (b > 5) {
	console.log('Выполнена команда 2');
} else if (b === 7 || b <= 5) {
	console.log('Выполнена команда 3');
} else {
	console.log('Ни одно из условий не выполнено');
}

// * Оператор switch * \\
// ? Т.к. таких ветвлений в скрипте JS может быть очень много, то для удобства записи и лаконичности в поздних редакциях придумали switch.
const weekDay = 'Воскресенье';

switch (weekDay) {
	case 'Понедельник':
		console.log('Учим JS');
		break;
	case 'Вторник':
		console.log('Верстаем сайт');
		break;
	case 'Среда':
		console.log('Учим jQuery');
		break;
	case 'Четверг':
		console.log('Учим PHP');
		break;
	case 'Пятница':
		console.log('Делаем домашнее задание');
		break;
	case 'Суббота':
		console.log('Встреча с друзьями');
		break;
	case 'Воскресенье':
		console.log('Поездка на велосипеде на природу');
		break;
	default:
		console.log('Указано некорректное значение!');
		break;
}

// Также, если нам нужно задать один и тот же кусочек кода для разных значений, то "кейсы" можно группировать.
const n = 4
switch (n) {
	case 1:
		console.log('1');
		break;
	case 2:
	case 3:
	case 4:
		console.log('2, 3 или 4');
		break;
	default:
		console.log('Указано некорректное значение!');
}

// ? Также стоит помнить, что "кейсы" в switch проверяются на строгое соответствие "===", а значит строка не будет равна числу. Поэтому, когда мы получаем данные от пользователя или сервера, нам нужно это учесть. И либо prompt() перевести в числовое значение, либо case в строковое.

// Также можно проверить на истину и логические выражения, для этого в параметр switch запишем "true", именно с ним он будет сверяться.
const answer = +prompt('Введите целое число')

switch (true) {
	case answer > 10:
		console.log('n > 10');
		break;
	case answer <= 10:
		console.log('n <= 10');
		break;
	default:
		console.log('Указано некорректное значение!');
}

// А что, если нам нужно более сложное условие, например узнать, что число больше 5, но меньше 10?
switch (true) {
	// case 5 < n < 10: // неправильная запись
	case answer >= 5 && answer <= 10:
		console.log('Указанное число попадает в промежуток между 5 и 10');
		break;
	default:
		console.log('Указанное число не попадает в промежуток между 5 и 10');
}

console.log();
/** ||---------------------------------------------->> 
* * Links:
* [Неявное преобразование типов данных] https://habr.com/ru/company/ruvds/blog/347866/
* [Преобразование типов для примитивов] https://learn.javascript.ru/type-conversions
* [Приведение типов в JS - Магия или простые правила?] https://geekjob.medium.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B2-js-9d6f1845ea96
*/ 