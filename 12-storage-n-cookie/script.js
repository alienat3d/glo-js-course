'use strict';

// * === WebStorage & Cookie === * \\

// ? Иногда у нас есть задача сохранить информацию, к которой можно будет получить доступ даже после перезагрузки страницы. Например cookie реализует разнообразную авторизацию: когда пользователь заходит на сайт, если он уже авторизовался ранее, то сайт проверит его cookies, найдёт нужный токен с логином и паролем и отобразит пользователя, как уже авторизованным на сайте. То же с корзиной товаров, например, пользователь может выйти с сайта или даже закрыть браузер, но при этом не потеряет набранные им в корзину товары. Или ещё распространённый пример это настройки отображения сайта, например цветовая гамма.

// ? Если зайти в Dev Tools во вкладку "Application", то слева в графе "Storage -> Local Storage" мы увидим сохранённые данные в специальный контейнер на локальной машине пользователя (или в постоянной памяти, используемой браузером). Эта информация будет опрошена при загрузке страницы и далее использована в JS.
// ? Создаётся глобальный объект Storage, где в виде ключ: значение сохраняются данные.

// * Работа с глобальным объектом localStorage * \\

// Т.к. это объект, то мы можем сохранять в него значения, как и в любые другие объекты
// localStorage['name'] = 'Al'; // теперь эта информация сохранена в постоянной памяти браузера и будет находится там, пока её вручную не очистят.

// Или мы могли бы сохранить, используя точечную нотацию
// localStorage.name = 'Kate';

// * == У объекта LocalStorage есть ряд специальных методов для работы с ним == * \\

// * Метод "setItem()"
// ? Записывает какую-то информацию в Local Storage. Передаются 2 аргумента: 1) ключ; 2) значение.

localStorage.setItem('username', 'Al');

// * Метод "getItem()"
// ? Получает информацию из Local Storage. Принимает 1 аргумент — ключ свойства объекта localStorage, значение которого нам нужно получить

// console.log(localStorage.getItem('username'));

// * Метод "removeItem()"
// ? Удаляет свойство из Local Storage. Принимает 1 аргумент — ключ свойства объекта localStorage, которое хотим удалить
// localStorage.removeItem('username');

// * Метод "clear()"
// ? Очищает полностью Local Storage
// localStorage.clear();

// console.log(localStorage);

// * == Практика с вёрсткой == * \\

// * 1.0 Получим все элементы со страницы
const input = document.getElementById('input');
const btnSave = document.getElementById('btn_save');
const btnRemove = document.getElementById('btn_remove');
const text = document.getElementById('text');

// 1.2 Функция, меняющая текст параграфа. Сделаем так, что параграф с id "text" будет показывать нам содержимое сохранённого в Local Storage текста.
const showText = function () {
	// text.textContent = localStorage.getItem('text');
	text.textContent = sessionStorage.getItem('text');
}

// 1.1 Повесим на btnSave обработчик события по клику, где функция будет сохранять значение введённого в строку ввода в localStorage
btnSave.addEventListener('click', function() {
	// localStorage.setItem('text', input.value);
	sessionStorage.setItem('text', input.value);
	showText();
})

// 1.3 Также повесим обработчик события и на кнопку удаления, которая, собственно, этим и будет заниматься
btnRemove.addEventListener('click', function() {
	// localStorage.removeItem('text');
	sessionStorage.removeItem('text');
	showText();
})

showText();

// ? Session Storage работает точно также, только с разницей в том, что информация в нём существует только пока открыта вкладка, а потом самоуничтожается.

// ? И Local Storage и Session Storage имеют свои ограничения по памяти. У первого это 10 мегабайта, у второго — 5 мегабайта. Но этого обычно хватает для большинства типовых задач, иначе можно использовать серверные мощности.

// * == Cookies == * \\

// ? Ещё один контейнер для хранения пользовательских настроек и данных это Cookies и работа с ним несколько сложнее, чем с Local & Session Storage. Cookie является частью HTTP протокола и информация оттуда чаще всего отправляется вместе с запросом на сервер. Служит он для работы с пользовательскими данными на сервере.

// ? У контейнера Cookie макс. размер 4 килобайта, а также ограничение кол-ва кук для одного домена. (Ранее это было 20)
// todo /!\ Крайне не рекомендуется использовать куки для больших объектов вроде корзины товара для интернет-магазина. Она может превысить 4 килобайта и функционал сломается.
// todo /!\ Также не рекомендуется использовать куки для хранения важной пользовательской информации. Это крайне не безопасно, т.к. вредоносная программа может отправить эту информацию через протокол HTTP и хакер получит доступ к данным пользователя, что недопустимо. [Всё это справедливо именно для реальных проектов на production]

// Запишем куку в специальном формате.
// ? У неё есть ряд параметров в дополнении к ключу и значению, такие как: 1) домен, с которого будет доступна данная кука (по умолчанию берётся тот домен, с которого она была создана и мы не можем указать другой домен, но на поддомене мы можем её получить); 2) путь, по которому доступна данная кука; 3) жизненный цикл куки, а также другие настройки, про которые можно почитать в ссылке внизу.
// Мы также укажем ей срок жизни 1 час в секундах или 3600, после которого она самоуничтожиться:
// document.cookie = 'login=admin; max-age=15';

// Или укажем ей срок годности в специальном формате:
// Понятно, что такой формат очень неудобен, но всё же мы можем подстроиться под него с помощью объекта Date. Если в конструктор Date ничего не передавать, то он возвращает текущую дату, но мы также можем передать указанную дату и время.
let date = new Date(2024, 5, 18, 5, 14, 33);

// Но также нам нужно перевести это всё в GMT, т.к. кука принимает в этом часовом поясе. Для этого применим метод "toUTCString()"
// console.log(date.toUTCString());

const formattedDate = date.toUTCString();

// document.cookie = 'login=admin; expires=Tue 18 Jun 2024 02:14:33 GMT';

// Теперь можно провести конкатенацию с датой, введённой вручную
document.cookie = 'login=admin; expires=' + formattedDate;

// ? В Cookies кладут не только информацию связанную с сервером, а любую информацию для работы сайта. Пример: Мы зашли впервые на какой-то сайт и нам показывают рекламный баннер. Мы его закрыли. И после, сколько бы мы не заходили на сайт, пока мы не удалим куки, этот баннер больше не покажется.

// ? Почему эту информацию положили именно в Cookies, а не в Local Storage? Дело в том, что огромный % сайтов так или иначе базируется на PHP (CMS системы), а PHP очень плохо работает с Local Storage, а именно не имеет к нему прямого доступа и прибегает к помощи JS, чтобы получить информацию из Local Storage. Возможно в будущих версиях это изменится, а может на текущий момент уже изменилось. (надо проверять) Поэтому долгое время было (и есть), что проще на сайтах, связанных с движком на PHP, сохранять информацию в Cookies. Так будет гораздо удобнее потом с ним работать.

// * == Что делать, если надо сохранить в Cookies целый объект? == * \\

const user = {
	name: 'Alex',
	city: 'Berlin',
	occupation: 'Senior Fullstack Developer',
	role: 'user'
}

// * Метод глобального объекта "JSON" — "stringify()"
// ? Переводит объект в строчное значение. Принимает аргументом объект.

// После того, как мы ввели название объекта строкой, нам нужно перевести объект в строку и применить к ним конкатенацию. С переводом объекта в строку нам поможет глобальный объект JSON и его метод "stringify()", с которым мы будем ещё очень часто работать.

document.cookie = 'user=' + JSON.stringify(user);

/* ||---------------------------------------------->> 
* Links:
* [][https://mdn.github.io/dom-examples/web-storage/] Демо LocalStorage
* [][https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API] Web Storage API
* [][https://learn.javascript.ru/cookie] Куки, document.cookie
* [][https://metanit.com/web/javascript/12.1.php] Хранение данных
* [][https://learn.javascript.ru/json] Формат JSON, метод toJSON
*/ 