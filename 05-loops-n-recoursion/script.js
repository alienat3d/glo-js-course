'use strict';

// * === Циклы и рекурсия === * \\

// ? Зачем нужны циклы? Когда мы пишем какую-то программу, то нам очень часто встречаются какие-то однотипные задачи, например вывести элементы на страницу или перебрать числа и для каждого выполнить одинаковые действия. Т.к. обращаться к большому кол-ву элементов по отдельности займёт много времени и создаст огромное кол-во кода, это не практично, поэтому придумали цикл (т.н. «прокрутка»).

// * == Рекурсия == * \\ 

// Рассмотрим на примере как он работает
// Представим на примере из жизни — нам нужно почистить картофель. Всем известная рутинная задача. У нас есть ведёрко картофеля. Каждую картофелину нужно взять в руки, почистить, помыть и выложить в миску.
let potatoes = 10;

// И можно было бы 10 раз вызвать сообщение в консоль, но это некрасивый способ и противоречит принципу DRY.
/* console.log('Картошка №1 почищена');
console.log('Картошка №2 почищена');
console.log('Картошка №3 почищена');
console.log('Картошка №4 почищена');
console.log('Картошка №5 почищена');
console.log('Картошка №6 почищена');
console.log('Картошка №7 почищена');
console.log('Картошка №8 почищена');
console.log('Картошка №9 почищена');
console.log('Картошка №10 почищена'); */

// Гораздо лучше было бы написать код, который бы 10 раз вывел нам сообщение в консоль.
// Также чистить мы будем, если будет передана картошка, для этого напишем условие if.
// Нам также надо учесть, что после того, как 1 картошка почищена их количество должно уменьшаться на 1.
const peelPotato = function (potatoIndex) {
	/* 	if (potatoIndex > 0) {
			console.log('Картошка №' + potatoIndex + ' почищена');
			potatoIndex--;
			console.log(potatoIndex);
		}
		if (potatoIndex > 0) {
			console.log('Картошка №' + potatoIndex + ' почищена');
			potatoIndex--;
			console.log(potatoIndex);
		}
		if (potatoIndex > 0) {
			console.log('Картошка №' + potatoIndex + ' почищена');
			potatoIndex--;
			console.log(potatoIndex);
		} */
	// Стоп, но это же ещё больше кода! Надо что-то изменить! А что если мы добавим вызов функции внутрь функции? Ура, сработало!
	// ? Это и называется "рекурсия", функция будет запускать саму себя пока условие верно, а потом, когда картошка достигнет 0 — остановится.
	// Сама рекурсия в современных реалиях используется редко, т.к. может быть опасной, если немного напутать с условием, то можно запустить функцию бесконечное кол-во раз ('infinity loop issue') и браузер зависнет.
	if (potatoIndex > 0) {
		console.log('Картошка №' + potatoIndex + ' почищена');
		potatoIndex--;
		peelPotato(potatoIndex);
	}
}

console.log(peelPotato(potatoes));

// * == Циклический оператор == * \\ 

// ? Есть более безопасный способ сделать тоже самое, чем рекурсия — циклические операторы. Всего их 3: «for», «while» и «do while».

// * Цикл «for» * \\
// ? Этот цикл принимает 3 параметра в () и содержит тело цикла в {}. 1-ый параметр: стартовая точка, тот индекс, с которого мы начинаем прокручивать наш цикл; 2-ой: условие, по которому цикл выполняется; 3-ий: действие, которое он производит каждую свою итерацию (повторение цикла).
// ? Также у нас есть опции внутри цикла прекратить его работу, либо пропустить какой-то шаг. Ключевое слово break прекратит выполнение цикла, а continue пропустит. Например мы можем пропустить вывод в консоль чистку 5-ой картошки.

for (let potatoIndex = 10; potatoIndex >= 0; potatoIndex--) {
	// if (potatoIndex === 5) continue;
	if (potatoIndex !== 5) console.log('Картошка №' + potatoIndex + ' почищена'); // более распространённая запись

	if (potatoIndex === 0) {
		console.log('Больше картошки не осталось!');
		break;
	}
}

// Мы можем инвертировать счёт картошки, чтобы она считалась от 0 до 10 слегка преобразив цикл

for (let potatoIndex = 1; potatoIndex <= 11; potatoIndex++) {
	if (potatoIndex === 11) {
		console.log('Больше картошки не осталось!');
		break;
	}
	console.log('Картошка №' + potatoIndex + ' почищена');
}

// * Цикл «while» * \\
// В параметрах while мы укажем условие, при котором цикл будет повторяться, т.е. пока условие возвращает true цикл будет дальше итерироваться. Но теперь, т.к. мы будем изменять potatoes необходимо ↑ "const" заменить на "let".

/* while (potatoes > 0) {
	console.log('Картошка №' + potatoes + ' почищена');
	potatoes--;
} */

// * Цикл «do while» * \\
// По сути, работает так же, как и «while», но в отличии от «while» он обязательно отработает хотя бы 1 раз, а после этого проверит условие. И так до тех пор, пока условие не вернёт false. В отдельных задачах без него просто не обойтись.
do {
	console.log('Картошка №' + potatoes + ' почищена');
	potatoes--;
} while (potatoes > 0);

// =================== \\
// Ещё примеры

const namesArr = ['Катя', 'Лёша', 'Даша', 'Саня', 'Оксана', 'Женя', 'Лена', 'Костя', 'Оля', 'Ирина', 'Антон', 'Егор', 'Тима', 'Толик', 'Вова'];

function printArr(arr, index = 0) {
	console.log(arr[index]);
	if (index < arr.length) printArr(arr, ++index);
}

printArr(namesArr);

function printArrReverse(arr, index) {
	console.log(arr[index]);
	if (index >= 0) printArrReverse(arr, --index);
}

printArrReverse(namesArr, namesArr.length);

/* ||---------------------------------------------->> 
* Links:
* [✓][https://habr.com/ru/post/337030/] Как работает рекурсия
*/ 