'use strict';


// ? structuredClone() — отличный метод для работы с объектами
const a = {
	name: 'Alex',
	age: 23
}

const b = a;

// b.name = 'Al';

// console.log(a.name); // 'Al'

// ? Объекты являются ссылочным типом данных, в JS один такой тип это объект. Массив и примитивы это не ссылочные типы данных. Поэтому в примере выше мы в переменную 'b' положили только ссылку на объект 'a', т.е. по факту мы через 'b' перешли по ссылке в объект 'a' и поменяли его свойство 'name'.

// * Но что же сделать, чтобы получить полный клон объекта, а не только его ссылку?
// ? Есть, например, один из таких способов, через spread-оператор (означает, что мы из объекта 'a' кладём все свойства в объект 'c'):
const c = {...a};

c.name = 'Al';

console.log(a.name); // 'Alex'

// ? Но что, если у нас более сложный вид объекта?
const d = {
	name: 'Josh',
	age: 30,
	children: {
		name: 'Jake',
		age: 10
	}
}

const e = {...d};

e.name = 'Wicky';
e.children.name = 'Jessica';

console.log(d.children.name); // Jessica

// ? Упс, получается, что у нас снова та же проблема, т.к. вложенный объект не клон, а только ссылка на объект d и мы снова переопределили одно из его свойства. Получается, что такой способ неполноценное клонирование, если у нас есть вложенные объекты.
// Мы столкнёмся с тем же самым, если используем метод глобального объекта "Object" "assign()"
const f = Object.assign({}, d);

f.children.name = 'Jackie';

console.log(d.children.name); // Jackie

// ? И вот, чтобы избежать подобных проблем долгое время использовали библиотеку _lodash и её метод cloneDeep(). Тогда у нас клонируются действительно все свойства объекта в другой, включая вложенные объекты.
// todo Требуется минимум 18 версия NodeJS
// * Но теперь мы можем обходиться даже без сторонних библиотек с помощью нового метода structuredClone()

const g = structuredClone(d);

g.children.name = 'Walter';

console.log(d.children.name);