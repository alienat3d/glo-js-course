'use strict';

// * === Обработчики ("слушатели") событий и особенности их работы === * \\

// * 1.0 Есть несколько способов отловить и обработать события в JS. Начнём с рассмотрения более устаревшей версии — атрибутом на элементе.
// 1.1.0 Мы пишем событие атрибутом в сам тег, начиная со слова "on" и дальше значением передаём в "" тот код, который должен сработать по этому событию.
// todo 1.1.1 /!\ Приведён только для примера, но на самом деле в текущее время не рекомендуется записывать JS в HTML, т.к. это затормаживает его загрузку. (такой приём можно встретить разве что на очень старых проектах)
// <button onclick="alert('click')"></button>

// * 1.2.0 Поэтому будем использовать более современный метод и для этого нам нужно получить кнопку из вёрстки
const btn = document.getElementById('btn');

// ? 1.2.1 На самом деле каждое событие это свойство объекта элемента и мы можем его заполнить, присвоив ему какую-то функцию.

const square = document.getElementById('square');

/* square.onclick = function () {
	alert('You clicked the square!');
} */

// ? Кстати, если зайти в браузере в Dev Tools -> Elements (клик по элементу) -> Event Listeners, то мы увидим информацию о обработчиках событий, которые висят на этом элементе

// * 1.3.4.1 [...]
let counter = 0;

// * 1.3.4.2 Ну и будем прибавлять 1 каждый раз, когда эта функция сработает, а также условие, что при достижении переменной числа 3, мы удалим обработчик со square.
const logger = function () {
	counter++;
	if (counter === 3) {
		square.removeEventListener('click', logger);
	}
	console.log('You clicked the element!');
}

/* const logger2 = function () {
	console.log('Did you clicked the element?');
} */
// todo Однако так делать неудобно, т.к. мы можем повесить лишь один обработчик таким способом и если попробовать повесить на этот элемент ещё один такой же обработчик, то он просто перезапишет предыдущий. Поэтому есть более удобный способ — метод "addEventListener"
// square.onclick = logger;
// square.onclick = logger2;

// console.dir(square);

// * 1.3.0 метод "addEventListener()"
// ? 1.3.1 Позволяет вешать сколь угодно обработчиков на один и тот же элемент и потому наиболее часто используется для этих задач в современном JS.
// 1.3.2.0 Используя метод "addEventListener" мы теперь можем без проблем повесить на элемент "square" оба наших события клика мыши. Этот метод принимает два аргумента: 1) название события строкой; 2) коллбэк-функцию, где будет что-то выполнятся, после того, как событие случилось
/* square.addEventListener('click', () => {
	logger();
	logger2();
}) */

// ? 1.3.2.1 Если функция одна, то можно сократить до:
square.addEventListener('click', logger);

// 1.3.2.2 Также сработает и дополнительный обработчик, если мы его создадим, ничего не перезатирая, как в предыдущем случае.
// square.addEventListener('click', () => console.log('Тра-ля-ля-ля-ля...'));

// * 1.3.3.0 Чтобы удалить обработчик с элемента есть метод "removeEventListener()"
// ? 1.3.3.1 Однако следует помнить, что удалить мы можем лишь именную функцию, а вот анонимную нет.
// square.removeEventListener('click', logger);

// * 1.3.4.0 Для примера зачем может понадобится удалять обработчик, давайте представим, что по ТЗ нам нужно удалить обработчик после ровно 3-ёх кликов. Для начала создадим специальную переменную, которая будет считать клики. [...] ↑

// * == Объект «Event» == * \\

// ? Каждая коллбэк-функция, которая передаётся в метод "addEventListener" получает внутри этого метода доступ к объекту данного события. И принимается этот объект в первом параметре, который принято обозначать "e", "evt" или иногда "event". (Но всё же лучше "evt", т.к. "е" не слишком понятно, а с переменной "event" в некоторых случаях могут возникнуть проблемы.) В этом объекте содержится вся информация о данном событии.
// Одним из самых полезных свойств и наиболее используемых является "target" — та цель, по которой мы кликнули. Так мы например можем использовать очень полезный приём наследования.

// * События при работе с формами * \\

// ? Довольно важная тема, т.к. JS часто работает именно с формами.

// * 1.4.0 Сперва получим саму строку ввода
// 1.4.3.0 Также получим элемент span, куда будем записывать значение, введённое в строку ввода.
const text = document.getElementById('text');
const span = document.getElementById('text-span');

// 1.4.1 Повесим на неё обработчик события "input"
/* text.addEventListener('input', logger); // сработает при введении текста в строку ввода
text.addEventListener('focus', logger); // сработает при фокусировке на строке ввода
text.addEventListener('blur', logger); // сработает при потери фокусировки на строке ввода
text.addEventListener('change', logger); // сработает при событии "input" & "blur" */

// 1.4.2 Итак создадим функцию, которая будет выводить содержимое введённого текста в строку ввода в консоль.
// 1.4.3.1 Мы также будем менять текстовое содержимое элемента span.
const showInputsValue = function (evt) {
	console.log(evt.type);
	span.textContent = evt.target.value;
}

const showRangeValue = function (evt) {
	console.log(evt.type);
	document.getElementById('range-span').textContent = evt.target.value;
}

// text.addEventListener('input', showInputsValue);

// * 1.5 Ещё два довольно популярных события в проверке строк ввода "keyup" & "keydown"
text.addEventListener('keydown', showInputsValue);
text.addEventListener('keyup', showInputsValue);

// * 1.6.0 Теперь поработаем немного с регулятором. Для этого сперва получим его.
// const inputRange = document.getElementById('range');
// const rangeSpan = document.getElementById('range-span');

// ? 1.6.1 Для элементов input-range используют оба события, но слушание события "input" выглядит гораздо красивее.
// ? 1.6.2 Кстати, мы могли бы подставить поиск элемента прямо перед навешиванием события на него. Этим мы можем сократить код, когда, например, уверены, что этот элемент будет использоваться только здесь и больше нигде ещё. Хотя с точки зрения читаемости, всё же лучше класть каждый элемент в отдельную переменную.
document.getElementById('range').addEventListener('input', showRangeValue); // сработает пока мы держим и двигаем регулятор мышью
// document.getElementById('range').addEventListener('change', showRangeValue); // сработает, когда отпустим кнопку мыши

// * == Другие полезные браузерные события == * \\

// * Событие "DOMContentLoaded"
// ? Сработает, когда интерпретатор считал всю вёрстку и построил на её основе DOM-дерево. Вешается на главный объект document.
// ? Это событие прежде использовалось вместо атрибута HTML-тега <script> "defer". В него заворачивался весь JS-код, который требует загрузки всей вёрстки для корректной работы. Сейчас, однако, когда появился "defer" это событие стало избыточным. [deprecated]
/* document.addEventListener('DOMContentLoaded', function () {
	console.log('DOM-дерево загрузилось');
}) */

// * Событие "onbeforeunload"
// ? Срабатывает тогда, когда пользователь внутри данной вкладки собирается перейти на другую страницу или просто перезагрузить страницу. Ранее им часто пользовались маркетинговые отделы и поэтому современные браузеры стали ставить на него блокировку. Более мы не можем вмешаться в текст данного модального окна. Также потеряло актуальность [deprecated]
/* window.onbeforeunload = function () {
	return 'Вы уверены, что хотите уйти со страницы?'
} */

// ? Есть ещё очень много событий, с которыми всегда можно ознакомиться на MDN при случае.

// * Метод объекта "Event" "preventDefault()"
// ? Отменяет стандартное поведение элементов на странице.
// К примеру, стандартное поведение ссылки — это переход на другую страницу. И мы можем запретить выполнять такие действия и, например, перевести его на другую страницу только при определённых условиях. Такое часто используется при валидации форм.

// ? 1.7.0 Потренируемся на ссылке, сперва получим её по тегу
const link = document.querySelector('a');

// 1.7.1 Чтобы запретить ссылке переход на страницу применим preventDefault();, который принято писать всегда в начале кусочка кода
link.addEventListener('click', (evt) => {
	evt.preventDefault();
	console.log('клик по ссылке');
})

// ? 1.8.0 Кстати, с помощью метода "preventDefault()" можно запретить пользователю на данной странице с помощью правой кнопки мыши открывать контекстное меню. Для этого нам понадобится событие contextmenu.
document.addEventListener('contextmenu', function (evt) {
	evt.preventDefault();
	console.log('Контекстное меню на этом сайте не доступно.');
})

// * == Всплытие и погружение событий == * \\

// ? Чтобы понимать делегирование нужно понимать, что обработчики события работают по принципу "всплытия событий", т.е. кликнув по дочерний элемент, мы также кликаем по всем его родительским. Событие как бы "всплывает" к верхним по иерархии в DOM-дереве элементам до самого <HTML> тега. Чтобы узнать какой точно элемент был кликнут мы используем "event.target".

// ? Также есть ещё свойство объекта "event" — "currentTarget".

// * 1.9.0 Получим нужные элементы
const button = document.querySelector('#e_btn');
const circleElement = document.querySelector('#circle');
const squareElement = document.querySelector('#square');

// 1.9.1 Создадим функцию, которая будет тогглить класс со стилем зелёного цвета
// * Метод "stopPropagation()"
// ? Мы можем останавливать эффект всплытия при помощи метода объекта "event" — "stopPropagation()", т.к. для некоторых задач это необходимо делать.
// * "Погружение" ("всплытие" наоборот)
// ? 1.10.0 Также мы можем повернуть эффект всплытия вспять и тогда это будет называться уже "погружение" (или "перехват"). Теперь мы идём не от кликнутого элемента к его родительским тегам по иерархии вверх, а наоборот от верхних родителей к тому, на который кликнули.
const toggler = function (evt) {
	// evt.stopPropagation();
	console.log('Событие сработало на ' + evt.target.id + ' и перенеслось на ' + evt.currentTarget.id); // мы получим все элементы, которые были кликнуты, т.к. они наслаиваются один под другим
	evt.target.classList.toggle('green');
}

// 1.9.2 И повесим обработчик с этой функцией на каждый из них
// 1.10.1 Чтобы активировать эффект погружения добавим третьим аргументом "true"
button.addEventListener('click', toggler, true);
circleElement.addEventListener('click', toggler, true);
squareElement.addEventListener('click', toggler, true);

// ? Зачастую, особенно на отдельно стоящих элементах, мы не увидим всплытия. Но иногда в более сложном функционале может случиться так, что у нас будет на родительском элементе одно событие клика, а на его дочернем элементе другое. И тогда, кликнув по дочернему элементу, запустим сразу два события. Тогда нужно вспомнить эти темы и соответственно отменить всплытие дочернему элементу.

/* ||---------------------------------------------->> 
* Links:
* [][https://learn.javascript.ru/introduction-browser-events] Введение в браузерные события
* [][https://developer.mozilla.org/ru/docs/Web/API/Event] Интерфейсы, основанные на Event
* [][https://developer.mozilla.org/ru/docs/Web/Events] Справочник по событиям
*/ 